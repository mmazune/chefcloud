# M11.1 Inventory Foundation - Hypotheses & Mitigations

## H1: Cross-Branch/Org Leakage

**Hypothesis:** If `branchId` or `orgId` filters are missing from queries, users could see/modify inventory from other organizations or branches.

**Risk:** HIGH - Data isolation violation

**Mitigation:**
1. All service methods require explicit `orgId` parameter
2. All queries include `WHERE orgId = $orgId AND branchId = $branchId`
3. E2E test: Create items in two orgs, verify isolation
4. Controller guards validate orgId from JWT matches request

**Test Case:**
```typescript
it('should not return items from other organizations', async () => {
  const org1Item = await service.createItem(org1Id, { name: 'Org1 Item' });
  const org2Items = await service.getItems(org2Id);
  expect(org2Items.find(i => i.id === org1Item.id)).toBeUndefined();
});
```

---

## H2: Unit Conversion Rounding Drift

**Hypothesis:** Repeated unit conversions (e.g., kg → g → kg) could accumulate floating-point errors, causing inventory discrepancies over time.

**Risk:** MEDIUM - Accounting accuracy

**Mitigation:**
1. Use `Decimal` (Prisma) / `decimal.js` for all quantity calculations
2. Store quantities in base unit, convert only for display
3. Define conversion factors as exact decimals (not floats)
4. Round to fixed precision (3 decimal places) at storage boundary

**Test Case:**
```typescript
it('should not drift on repeated conversions', () => {
  const kgToG = new Decimal(1000);
  const original = new Decimal('1.123');
  const inGrams = original.times(kgToG);
  const backToKg = inGrams.div(kgToG);
  expect(backToKg.equals(original)).toBe(true);
});
```

---

## H3: Race Conditions Causing Negative Stock

**Hypothesis:** Concurrent adjustments could bypass negative stock validation if not properly serialized.

**Risk:** HIGH - Business rule violation

**Mitigation:**
1. Use database transaction with `SERIALIZABLE` isolation for adjustments
2. Recheck on-hand INSIDE transaction before insert
3. Use `SELECT ... FOR UPDATE` on relevant ledger entries (or aggregate lock)
4. Alternative: Pessimistic locking at application level

**Implementation:**
```typescript
await this.prisma.client.$transaction(async (tx) => {
  // Lock by reading current state
  const currentOnHand = await this.getOnHandWithLock(tx, itemId, locationId, branchId);
  
  if (currentOnHand.plus(delta).lessThan(0) && !allowNegative) {
    throw new BadRequestException('Would result in negative stock');
  }
  
  await tx.inventoryLedgerEntry.create({ data: {...} });
}, { isolationLevel: 'Serializable' });
```

**Test Case:**
```typescript
it('should prevent negative stock under concurrent adjustments', async () => {
  // Set initial stock to 10
  await service.recordEntry(itemId, locationId, branchId, new Decimal(10));
  
  // Attempt two concurrent -8 adjustments (should fail one)
  const results = await Promise.allSettled([
    service.createAdjustment(itemId, locationId, branchId, -8),
    service.createAdjustment(itemId, locationId, branchId, -8),
  ]);
  
  const successes = results.filter(r => r.status === 'fulfilled');
  const failures = results.filter(r => r.status === 'rejected');
  
  expect(successes.length).toBe(1);
  expect(failures.length).toBe(1);
});
```

---

## H4: Count Finalize Idempotency Failure

**Hypothesis:** Multiple rapid calls to `finalizeCount()` could create duplicate ledger entries if idempotency check fails.

**Risk:** HIGH - Inventory accuracy

**Mitigation:**
1. First action in transaction: Check `status === 'FINALIZED'`
2. If already finalized, return immediately WITHOUT creating entries
3. Use unique constraint on `(countSessionId, itemId, locationId)` in ledger as backup
4. Wrap entire finalize in single transaction

**Implementation:**
```typescript
async finalizeCount(sessionId: string): Promise<CountSession> {
  return this.prisma.client.$transaction(async (tx) => {
    const session = await tx.countSession.findUnique({
      where: { id: sessionId },
      include: { lines: true },
    });
    
    // IDEMPOTENT CHECK - MUST BE FIRST
    if (session.status === 'FINALIZED') {
      this.logger.log(`Count session ${sessionId} already finalized, returning`);
      return session;
    }
    
    // Process lines...
    // Update status to FINALIZED
  });
}
```

**Test Case:**
```typescript
it('should be idempotent on multiple finalize calls', async () => {
  const session = await service.createCountSession(...);
  await service.addCountLine(session.id, itemId, locationId, 100);
  
  // Finalize twice rapidly
  const [result1, result2] = await Promise.all([
    service.finalizeCount(session.id),
    service.finalizeCount(session.id),
  ]);
  
  expect(result1.status).toBe('FINALIZED');
  expect(result2.status).toBe('FINALIZED');
  
  // Only ONE set of ledger entries should exist
  const entries = await prisma.inventoryLedgerEntry.findMany({
    where: { sourceId: session.id },
  });
  expect(entries.length).toBe(1); // One entry per line
});
```

---

## H5: Export Hash Mismatch on Windows

**Hypothesis:** CSV exports could have different hashes on Windows vs Linux due to line ending differences (`\r\n` vs `\n`).

**Risk:** MEDIUM - Audit trail integrity

**Mitigation:**
1. Normalize line endings to `\r\n` BEFORE hashing (Windows convention for CSV)
2. Include BOM for Excel compatibility
3. Hash the final content after all normalization
4. Document expected line ending format

**Implementation:**
```typescript
export function generateCsvWithHash(rows: string[][]): { content: string; hash: string } {
  const BOM = '\uFEFF';
  const csvLines = rows.map(row => row.join(',')).join('\r\n');
  const content = BOM + csvLines + '\r\n';
  
  const hash = crypto.createHash('sha256').update(content, 'utf8').digest('hex');
  
  return { content, hash };
}
```

**Test Case:**
```typescript
it('should produce consistent hash regardless of platform', () => {
  const rows = [['a', 'b'], ['c', 'd']];
  const { hash: hash1 } = generateCsvWithHash(rows);
  const { hash: hash2 } = generateCsvWithHash(rows);
  expect(hash1).toBe(hash2);
  
  // Verify content has \r\n
  const { content } = generateCsvWithHash(rows);
  expect(content).toContain('\r\n');
  expect(content).not.toMatch(/[^\r]\n/); // No bare \n
});
```

---

## H6: Test Hangs from Unclosed Handles

**Hypothesis:** E2E tests could hang if database connections, timers, or event emitters are not properly closed.

**Risk:** HIGH - CI/CD reliability

**Mitigation:**
1. Use `testDbSuffix` pattern for isolated test databases
2. Call `await prisma.$disconnect()` in `afterAll`
3. Clear all timers with `jest.clearAllTimers()` if using fakeTimers
4. Avoid `setInterval` in services; use on-demand computation
5. Set Jest timeout to 30s with failfast

**Test Pattern:**
```typescript
describe('InventoryLedgerService', () => {
  let prisma: PrismaService;
  let module: TestingModule;
  
  beforeAll(async () => {
    module = await Test.createTestingModule({
      imports: [PrismaModule.forTest('inventory_ledger_test')],
      providers: [InventoryLedgerService],
    }).compile();
    
    prisma = module.get(PrismaService);
  });
  
  afterAll(async () => {
    await prisma.$disconnect();
    await module.close();
  });
  
  // tests...
});
```

---

## H7: RBAC Privilege Escalation

**Hypothesis:** Users with L2 (read) could craft requests to bypass guards and write inventory data.

**Risk:** HIGH - Security violation

**Mitigation:**
1. Use `@UseGuards(RolesGuard)` on all controller methods
2. Define minimum role per endpoint in decorator
3. Service methods do NOT check auth (controller responsibility)
4. E2E test: Attempt write operations with L2 user, expect 403

**Implementation:**
```typescript
@Controller('inventory')
@UseGuards(JwtAuthGuard, RolesGuard)
export class InventoryController {
  @Get('items')
  @Roles('L2', 'L3', 'L4', 'L5')
  async getItems() { ... }
  
  @Post('items')
  @Roles('L3', 'L4', 'L5')
  async createItem() { ... }
  
  @Post('locations')
  @Roles('L4', 'L5')
  async createLocation() { ... }
}
```

**Test Case:**
```typescript
it('should reject L2 user from creating items', async () => {
  const response = await request(app.getHttpServer())
    .post('/inventory/items')
    .set('Authorization', `Bearer ${l2UserToken}`)
    .send({ name: 'Test Item' });
  
  expect(response.status).toBe(403);
});
```

---

## H8: SKU Uniqueness Not Enforced Per Org

**Hypothesis:** Without proper constraints, two items with the same SKU could exist in the same org, causing lookup ambiguity.

**Risk:** MEDIUM - Data integrity

**Mitigation:**
1. Existing constraint: `@@unique([orgId, sku])` on InventoryItem ✓
2. Service validates SKU uniqueness before create
3. Handle Prisma unique constraint errors with user-friendly message
4. SKU can be null (optional), unique constraint only applies to non-null

**Implementation:**
```typescript
async createItem(orgId: string, dto: CreateInventoryItemDto) {
  try {
    return await this.prisma.client.inventoryItem.create({
      data: { orgId, ...dto },
    });
  } catch (error) {
    if (error.code === 'P2002' && error.meta?.target?.includes('sku')) {
      throw new ConflictException(`SKU '${dto.sku}' already exists in this organization`);
    }
    throw error;
  }
}
```

**Test Case:**
```typescript
it('should reject duplicate SKU in same org', async () => {
  await service.createItem(orgId, { name: 'Item 1', sku: 'SKU001' });
  
  await expect(
    service.createItem(orgId, { name: 'Item 2', sku: 'SKU001' })
  ).rejects.toThrow('SKU \'SKU001\' already exists');
});

it('should allow same SKU in different orgs', async () => {
  await service.createItem(org1Id, { name: 'Item 1', sku: 'SKU001' });
  
  const item2 = await service.createItem(org2Id, { name: 'Item 2', sku: 'SKU001' });
  expect(item2.sku).toBe('SKU001');
});
```

---

## Summary

| Hypothesis | Risk | Status | Mitigation |
|------------|------|--------|------------|
| H1: Cross-branch leakage | HIGH | MITIGATED | Explicit orgId/branchId in all queries |
| H2: Rounding drift | MEDIUM | MITIGATED | Decimal.js, base unit storage |
| H3: Race conditions | HIGH | MITIGATED | Serializable transactions |
| H4: Idempotency failure | HIGH | MITIGATED | Check-first-in-transaction |
| H5: Hash mismatch | MEDIUM | MITIGATED | Normalize to CRLF before hash |
| H6: Test hangs | HIGH | MITIGATED | Proper cleanup in afterAll |
| H7: RBAC escalation | HIGH | MITIGATED | Guards on all endpoints |
| H8: SKU uniqueness | MEDIUM | MITIGATED | Existing DB constraint + error handling |

---

*Created: M11.1 STEP 2*
