# M11.9 Inventory Production/Manufacturing Batches Dossier

**Status:** IN PROGRESS  
**Date:** January 6, 2026  

## Executive Summary

M11.9 implements production/manufacturing batch capabilities for inventory management:
- ProductionBatch + ProductionBatchLine models (DRAFT→POSTED→VOID workflow)
- Ledger integration with PRODUCTION_CONSUME (negative) and PRODUCTION_PRODUCE (positive)
- Lot traceability via LotLedgerAllocation for consumed lots (FEFO)
- Costing integration (output cost = sum of input WAC at posting time)
- Full RBAC enforcement (L2+ read, L3+ create/post, L4+ void/export)

## Feature Comparison - InvenTree Reference

### InvenTree Build Order Pattern (STUDY-ONLY)

**Concepts extracted from InvenTree's manufacturing module:**

1. **Build Order Model** (`build/models.py`):
   - Links to BOM (Bill of Materials) for input parts
   - Status workflow: PENDING → PRODUCTION → COMPLETED
   - Build outputs created as StockItem records with `is_building=True`
   - Allocations tracked via BuildLine/BuildItem

2. **Stock Consumption Pattern**:
   - `consume_build_line` / `consume_build_item` tasks consume allocated stock
   - `complete_allocation()` either installs trackable parts or marks as consumed
   - Consumed items have `consumed_by = build` and `location = None`

3. **Build Output Pattern**:
   - `create_build_output()` creates output stock items
   - Quantity tracking via `completed_items` count
   - Serial/batch code assignment on output

4. **API Structure** (`build/api.py`):
   - BuildOutputCreate, BuildOutputComplete, BuildOutputScrap endpoints
   - BuildAllocate, BuildConsume, BuildAutoAllocate actions
   - Serializers handle validation and atomic transactions

### NimbusPOS Adaptation

| InvenTree Concept | NimbusPOS M11.9 Equivalent |
|-------------------|---------------------------|
| Build Order | ProductionBatch |
| BuildLine | ProductionBatchLine (inputs) |
| BuildItem (allocation) | LotLedgerAllocation |
| consume_build_item | PRODUCTION_CONSUME ledger entry |
| complete_build_output | PRODUCTION_PRODUCE ledger entry |
| StockItem.consumed_by | sourceType='PRODUCTION', sourceId |
| BOM | Recipe (M11.4) - optional reference |

## Feature Specifications

### 1. Production Batch

**Model:** `ProductionBatch`
- **Status Workflow:** DRAFT → POSTED → VOID
- **Location-Scoped:** Production happens at a specific location
- **Output Item:** Single output item per batch (with quantity)
- **Cost Tracking:** Output cost calculated from input WAC

**Fields:**
| Field | Type | Description |
|-------|------|-------------|
| id | String | CUID primary key |
| orgId | String | Organization scope |
| branchId | String | Branch scope |
| batchNumber | String | Auto-generated reference |
| productionLocationId | String | Where production occurs |
| outputItemId | String | Produced item |
| outputQty | Decimal | Quantity produced |
| outputUomId | String | Unit of measure for output |
| outputBaseQty | Decimal | Base UoM qty |
| outputCost | Decimal? | Calculated on POST |
| recipeId | String? | Optional recipe reference |
| status | ProductionBatchStatus | DRAFT/POSTED/VOID |
| producedAt | DateTime? | When posted |
| producedById | String? | Who posted |
| voidedAt | DateTime? | When voided |
| voidedById | String? | Who voided |
| voidReason | String? | Reason for void |
| notes | String? | User notes |
| metadata | Json? | Extensible data |

### 2. Production Batch Line

**Model:** `ProductionBatchLine`
- Represents consumed inputs
- Links to specific lots for FEFO traceability

**Fields:**
| Field | Type | Description |
|-------|------|-------------|
| id | String | CUID primary key |
| batchId | String | Parent batch |
| itemId | String | Consumed item |
| locationId | String | Source location |
| lotId | String? | Specific lot (else FEFO) |
| uomId | String | Unit of measure |
| qty | Decimal | Consumed quantity |
| baseQty | Decimal | Base UoM qty |
| consumedBaseQty | Decimal? | Actual consumed (POST) |
| unitCostAtPost | Decimal? | WAC at posting time |
| notes | String? | Line notes |

### 3. Ledger Integration

On **POST**:
1. For each input line:
   - Create PRODUCTION_CONSUME ledger entry (negative qty)
   - Decrement lot.remainingQty (FEFO if no lotId specified)
   - Create LotLedgerAllocation records
   - Capture unitCostAtPost from current WAC
2. For output:
   - Create PRODUCTION_PRODUCE ledger entry (positive qty)
   - Create InventoryCostLayer with computed cost
   - outputCost = sum(line.consumedBaseQty × line.unitCostAtPost)

On **VOID**:
1. Create reversal ledger entries for all PRODUCTION_CONSUME (positive)
2. Create reversal ledger entry for PRODUCTION_PRODUCE (negative)
3. Restore lot.remainingQty for each consumed lot
4. Mark batch status = VOID

### 4. Costing Formula

```
outputCost = Σ (inputLine.consumedBaseQty × inputLine.unitCostAtPost)
outputUnitCost = outputCost / outputBaseQty
```

This ensures production output carries forward the weighted cost of all inputs.

### 5. RBAC Matrix

| Operation | Required Level | Notes |
|-----------|---------------|-------|
| List batches | L2+ | Branch-scoped |
| Get batch details | L2+ | Branch-scoped |
| Create batch | L3+ | Manager+ |
| Add/remove lines | L3+ | While DRAFT |
| Post batch | L3+ | Irreversible |
| Void batch | L4+ | Admin/Owner only |
| Export CSV | L4+ | Admin/Owner only |

## API Endpoints

| Method | Endpoint | Access | Description |
|--------|----------|--------|-------------|
| POST | `/inventory/production` | L3+ | Create draft batch |
| GET | `/inventory/production` | L2+ | List batches |
| GET | `/inventory/production/:id` | L2+ | Get details |
| POST | `/inventory/production/:id/lines` | L3+ | Add input line |
| DELETE | `/inventory/production/:id/lines/:lineId` | L3+ | Remove line |
| PATCH | `/inventory/production/:id/post` | L3+ | Post batch |
| PATCH | `/inventory/production/:id/void` | L4+ | Void batch |
| GET | `/inventory/production/export` | L4+ | CSV export |

## Schema Changes

### New Enum
```prisma
enum ProductionBatchStatus {
  DRAFT  // Created, can edit lines
  POSTED // Finalized, ledger entries created
  VOID   // Cancelled after post
}
```

### New Models
```prisma
model ProductionBatch {
  id                   String                @id @default(cuid())
  orgId                String
  branchId             String
  batchNumber          String                // Auto-generated
  productionLocationId String
  outputItemId         String
  outputQty            Decimal               @db.Decimal(12, 4)
  outputUomId          String
  outputBaseQty        Decimal               @db.Decimal(12, 4)
  outputCost           Decimal?              @db.Decimal(12, 4)
  recipeId             String?
  status               ProductionBatchStatus @default(DRAFT)
  producedAt           DateTime?
  producedById         String?
  voidedAt             DateTime?
  voidedById           String?
  voidReason           String?
  notes                String?
  metadata             Json?
  createdById          String
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt

  // Relations
  org                Org                     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch             Branch                  @relation("ProductionBatchBranch", fields: [branchId], references: [id], onDelete: Cascade)
  productionLocation InventoryLocation       @relation("ProductionBatchLocation", fields: [productionLocationId], references: [id], onDelete: Restrict)
  outputItem         InventoryItem           @relation("ProductionBatchOutputItem", fields: [outputItemId], references: [id], onDelete: Restrict)
  outputUom          UnitOfMeasure           @relation("ProductionBatchOutputUom", fields: [outputUomId], references: [id], onDelete: Restrict)
  recipe             Recipe?                 @relation("ProductionBatchRecipe", fields: [recipeId], references: [id], onDelete: SetNull)
  producedBy         User?                   @relation("ProductionBatchProducer", fields: [producedById], references: [id], onDelete: SetNull)
  voidedBy           User?                   @relation("ProductionBatchVoider", fields: [voidedById], references: [id], onDelete: SetNull)
  createdBy          User                    @relation("ProductionBatchCreator", fields: [createdById], references: [id], onDelete: Restrict)
  lines              ProductionBatchLine[]

  @@unique([orgId, branchId, batchNumber])
  @@index([orgId, branchId])
  @@index([status])
  @@map("production_batches")
}

model ProductionBatchLine {
  id              String          @id @default(cuid())
  batchId         String
  itemId          String
  locationId      String
  lotId           String?
  uomId           String
  qty             Decimal         @db.Decimal(12, 4)
  baseQty         Decimal         @db.Decimal(12, 4)
  consumedBaseQty Decimal?        @db.Decimal(12, 4)
  unitCostAtPost  Decimal?        @db.Decimal(12, 4)
  notes           String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  batch    ProductionBatch   @relation(fields: [batchId], references: [id], onDelete: Cascade)
  item     InventoryItem     @relation("ProductionLineItem", fields: [itemId], references: [id], onDelete: Restrict)
  location InventoryLocation @relation("ProductionLineLocation", fields: [locationId], references: [id], onDelete: Restrict)
  lot      InventoryLot?     @relation("ProductionLineLot", fields: [lotId], references: [id], onDelete: SetNull)
  uom      UnitOfMeasure     @relation("ProductionLineUom", fields: [uomId], references: [id], onDelete: Restrict)

  @@index([batchId])
  @@index([itemId])
  @@index([lotId])
  @@map("production_batch_lines")
}
```

### New Ledger Entry Reasons
```typescript
// Add to LedgerEntryReason enum
PRODUCTION_CONSUME = 'PRODUCTION_CONSUME',  // Negative - input consumed
PRODUCTION_PRODUCE = 'PRODUCTION_PRODUCE',  // Positive - output created

// Add to LedgerSourceType enum
PRODUCTION = 'PRODUCTION',  // Source is ProductionBatch
```

## Files to Create/Modify

| File | Change Type |
|------|-------------|
| `packages/db/prisma/schema.prisma` | Modified - M11.9 models |
| `services/api/src/inventory/inventory-production.service.ts` | Created |
| `services/api/src/inventory/inventory-production.controller.ts` | Created |
| `services/api/src/inventory/inventory-ledger.service.ts` | Modified - new reasons |
| `services/api/src/inventory/inventory.module.ts` | Modified - register M11.9 |
| `services/api/test/e2e/inventory-m119-production.e2e-spec.ts` | Created |
| `apps/web/src/pages/inventory/production-batches.tsx` | Created |
| `apps/web/src/pages/inventory/production-batch-detail.tsx` | Created |

## Hypotheses (Pre-Implementation)

| ID | Hypothesis | Test Strategy |
|----|------------|---------------|
| H1 | POST idempotency - double POST should not create duplicate ledger entries | Test: POST same batch twice, verify single set of ledger entries |
| H2 | VOID restores lot remainingQty correctly | Test: POST, VOID, check lot.remainingQty = original |
| H3 | Costing uses WAC at POST time, not current WAC | Test: Add cost layer after batch creation but before POST, verify captured cost |
| H4 | Cross-branch isolation - cannot POST batch to different branch's location | Test: Create batch, POST with wrong branchId, expect 403/404 |
| H5 | Negative stock prevention - cannot POST if inputs exceed on-hand | Test: Create line with qty > on-hand, POST, expect 400 |
| H6 | Export hash matches content | Test: Export, recompute SHA256, verify match |
| H7 | RBAC enforced - L2 cannot POST, L3+ can create, L4+ can void | Test: Different role levels, verify access control |
| H8 | Tests do not hang - app.close() properly called | Test: Teardown check, no open handles |

## Domain Invariants

### Business Rules

| ID | Rule | Enforcement |
|----|------|-------------|
| BR-01 | Output qty must be positive | API validation |
| BR-02 | At least one input line required to POST | Service validation |
| BR-03 | All lines must have same branchId as batch | Service validation |
| BR-04 | Cannot edit/delete lines once POSTED | Service validation |
| BR-05 | Cannot VOID an already VOID batch | Service validation |
| BR-06 | productionLocationId must be active | Service validation |
| BR-07 | lotId (if specified) must have sufficient remainingQty | Service validation |

### Data Invariants

| ID | Invariant | How Enforced |
|----|-----------|--------------|
| DI-01 | Ledger is append-only | No DELETE/UPDATE on ledger |
| DI-02 | sum(line.consumedBaseQty × line.unitCostAtPost) = batch.outputCost | Calculated in transaction |
| DI-03 | lot.remainingQty >= 0 after any operation | Check in service |
| DI-04 | batchNumber unique per org+branch | DB unique constraint |

### State Machine

```
DRAFT → POSTED → VOID
  ↓
 [delete allowed]
```

- DRAFT: Can add/remove lines, delete batch
- POSTED: Immutable, ledger entries exist
- VOID: Immutable, reversal entries exist

## UI Components

### Production Batches List Page
- Table with columns: Batch #, Output Item, Qty, Status, Date, Actions
- Filters: Status, Date range
- Actions: New Batch, Export

### Production Batch Detail Page
- Header: Batch info, status badge
- Input Lines section: Table of consumed items
- Output section: Produced item with cost breakdown
- Actions: Add Line (DRAFT), Post (DRAFT), Void (POSTED)

## Verification Gates

| Gate | Command | Timeout |
|------|---------|---------|
| API Lint | `pnpm --filter api lint` | 60s |
| Web Lint | `pnpm --filter web lint` | 60s |
| API Build | `pnpm --filter api build` | 120s |
| Web Build | `pnpm --filter web build` | 180s |
| M11.9 E2E | `pnpm test:e2e -- --testPathPatterns=m119` | 120s |
| Teardown Check | Verify no open handles | 30s |

## Dependencies

- M11.1: Inventory Foundation (items, locations)
- M11.5: Costing (WAC, InventoryCostLayer)
- M11.7: Lots/Traceability (InventoryLot, LotLedgerAllocation)
- M11.4: Recipes (optional recipe reference)

## Export Format

### CSV Columns
```
batchNumber,outputItemCode,outputItemName,outputQty,outputCost,status,producedAt,producedBy,inputCount,notes
```

### Hash Verification
SHA256 hash returned with export for content integrity.
