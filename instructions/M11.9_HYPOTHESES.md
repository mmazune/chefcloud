# M11.9 Production Batches Hypotheses

**Status:** PRE-IMPLEMENTATION  
**Date:** January 6, 2026

## Purpose

These hypotheses identify potential edge cases and failure modes for M11.9 Production Batches.
Each hypothesis will be tested via E2E tests before the feature is considered complete.

---

## H1: Idempotent POST - No Duplicate Ledger Entries

**Risk:** If POST is called twice (network retry, double-click), duplicate ledger entries could corrupt inventory counts.

**Hypothesis:** A second POST on an already-POSTED batch should return success without creating additional ledger entries.

**Test Strategy:**
1. Create draft batch with lines
2. POST batch (status → POSTED, ledger entries created)
3. Count ledger entries
4. POST same batch again
5. Verify: No new ledger entries, same count

**Implementation:** Check status before processing; if already POSTED, return idempotent success.

---

## H2: VOID Restores Lot remainingQty

**Risk:** VOID creates reversal ledger entries but fails to restore lot.remainingQty, causing drift between lot tracking and ledger totals.

**Hypothesis:** After VOIDing a posted batch, each consumed lot's remainingQty equals its value before the original POST.

**Test Strategy:**
1. Create lot with remainingQty = 100
2. Create batch line consuming 30 from that lot
3. POST batch (lot.remainingQty → 70)
4. Record lot state
5. VOID batch
6. Verify: lot.remainingQty = 100 (restored)

**Implementation:** In void transaction, restore lot.remainingQty for each LotLedgerAllocation.

---

## H3: Costing Uses WAC at POST Time

**Risk:** If costing captures current WAC at query time rather than POST time, delayed POSTs could use incorrect costs, causing audit discrepancies.

**Hypothesis:** unitCostAtPost is captured and stored at POST time; subsequent cost layer additions do not affect already-posted batches.

**Test Strategy:**
1. Create cost layer for item A (WAC = 10.00)
2. Create batch line consuming item A
3. Add another cost layer for item A (WAC → 15.00)
4. POST batch
5. Verify: line.unitCostAtPost = 15.00 (current WAC at POST, not creation time)
6. Create new cost layer (WAC → 20.00)
7. Verify: line.unitCostAtPost still 15.00 (immutable after POST)

**Implementation:** Capture WAC via costingService.getCurrentWac() inside POST transaction.

---

## H4: Cross-Branch Isolation

**Risk:** A user could create a batch in Branch A but reference a location in Branch B, causing cross-contamination of inventory.

**Hypothesis:** POST fails if productionLocationId belongs to a different branch than the batch's branchId.

**Test Strategy:**
1. Create location in Branch A
2. Create batch with branchId = Branch B but productionLocationId = Branch A location
3. Attempt POST
4. Verify: 400 BadRequest with "location does not belong to branch"

**Implementation:** Validate location.branchId === batch.branchId before processing.

---

## H5: Negative Stock Prevention

**Risk:** If input line quantity exceeds available on-hand, POST could result in negative inventory.

**Hypothesis:** POST fails with 400 if any input line's baseQty exceeds available on-hand at that location.

**Test Strategy:**
1. Set up item with on-hand = 50 at location
2. Create batch line consuming 100
3. POST batch
4. Verify: 400 BadRequest with "insufficient stock"
5. On-hand unchanged (no partial consumption)

**Implementation:** Check on-hand for each line before consuming; rollback entire transaction on failure.

---

## H6: Export Hash Matches Content

**Risk:** Export endpoint could have inconsistent hash calculation, failing content verification.

**Hypothesis:** The SHA256 hash returned with CSV export matches the hash computed from the CSV content.

**Test Strategy:**
1. Create and POST multiple batches
2. Call export endpoint
3. Extract returned hash
4. Compute SHA256 of CSV content
5. Verify: Hashes match

**Implementation:** Use same hash algorithm consistently; return `{ csv, hash }` object.

---

## H7: RBAC Enforcement

**Risk:** Incorrect role guards could allow unauthorized access to sensitive operations.

**Hypothesis:**
- L2 (Shift Lead) can LIST and GET batches
- L2 CANNOT POST or VOID
- L3 (Manager) can CREATE, POST
- L3 CANNOT VOID
- L4 (Admin/Owner) can VOID and EXPORT

**Test Strategy:**
1. Test each endpoint with L2 user → verify 403 on POST, VOID, EXPORT
2. Test with L3 user → verify 200 on CREATE, POST; 403 on VOID
3. Test with L4 user → verify 200 on all operations

**Implementation:** Controller decorators: `@Roles('L2_SHIFT_LEAD')`, `@Roles('L3_MANAGER')`, `@Roles('L4_ADMIN')`.

---

## H8: Tests Do Not Hang - Clean Teardown

**Risk:** Test files that don't properly close app/prisma leave handles open, causing Jest to hang.

**Hypothesis:** M11.9 E2E test file completes within 120s with no open handles warning.

**Test Strategy:**
1. Run `pnpm test:e2e -- --testPathPatterns=m119 --detectOpenHandles`
2. Verify: Exit code 0
3. Verify: No "Jest did not exit" warning
4. Verify: Runtime < 120s

**Implementation:** Follow E2E_NO_HANG_STANDARD.md:
- Use `createE2EApp()` with try/catch
- Always `app.close()` in `afterAll`
- Never use `forceExit`

---

## Verification Checklist

| Hypothesis | Test File | Status |
|------------|-----------|--------|
| H1 | inventory-m119-production.e2e-spec.ts | PENDING |
| H2 | inventory-m119-production.e2e-spec.ts | PENDING |
| H3 | inventory-m119-production.e2e-spec.ts | PENDING |
| H4 | inventory-m119-production.e2e-spec.ts | PENDING |
| H5 | inventory-m119-production.e2e-spec.ts | PENDING |
| H6 | inventory-m119-production.e2e-spec.ts | PENDING |
| H7 | inventory-m119-production.e2e-spec.ts | PENDING |
| H8 | Teardown check / --detectOpenHandles | PENDING |

---

## Summary

8 hypotheses covering:
- **Idempotency:** H1
- **Data Integrity:** H2, H3, H5
- **Security:** H4, H7
- **Observability:** H6
- **Test Quality:** H8

All hypotheses will be verified via E2E tests before M11.9 is marked complete.
