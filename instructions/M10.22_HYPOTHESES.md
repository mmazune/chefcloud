# M10.22 Hypotheses Document

## Pre-Implementation Hypotheses

These hypotheses identify potential failure modes for M10.22 Kiosk Ops Hardening. Each must be validated before/during implementation.

---

## Hypothesis Table

| ID | Hypothesis | Confidence | Failure Mode | Mitigation | Test Requirement |
|----|-----------|------------|--------------|------------|------------------|
| H1 | Batch ingest duplicates time entries if idempotency is not enforced per device | HIGH | Same event creates multiple time entries, payroll errors | UNIQUE constraint on (kioskDeviceId, idempotencyKey), check before action | E2E: same key twice → same result |
| H2 | Offline queued events re-order and break invariants (clock-out before clock-in) | MEDIUM | Invalid state, rejected events | Server-side ordering validation, reject illegal sequences with code | E2E: out-of-order batch → proper rejections |
| H3 | Heartbeat/session logic introduces open handles (timers) and causes Jest hang | HIGH | E2E tests hang, CI failure | All "expiry" computed via DB queries (NOW - lastHeartbeatAt), no setTimeout/setInterval | E2E: test exits cleanly |
| H4 | PIN hashing/logging stores sensitive data (raw pin leakage) | HIGH | Security breach, compliance violation | Never store raw PIN, only masked suffix or hash prefix | Code review: no raw pin storage |
| H5 | Export hash differs on Windows due to BOM/newlines ordering | MEDIUM | Hash verification fails across platforms | Normalize line endings to LF before hash, consistent ordering | E2E: hash matches computed |
| H6 | Fraud rate-limits block legitimate use after intermittent failures | MEDIUM | Users locked out, ops disruption | Sliding window decay, clear rate limit on success | E2E: success resets window |
| H7 | Audit metadata missing kioskDeviceId/branchId breaks traceability | HIGH | Cannot trace events to devices/branches | All audit calls include required context | Code review: audit completeness |
| H8 | UI offline queue never flushes and causes silent backlog | MEDIUM | Lost events, data inconsistency | Clear queue on successful sync, show queue count, manual sync button | UI test: sync clears queue |
| H9 | Batch processing timeout causes partial completion | MEDIUM | Some events processed, others not | Transaction per batch, atomic accept/reject | E2E: batch is atomic |
| H10 | Health status computation race condition | LOW | Device shown as OFFLINE when actually ONLINE | Use consistent timestamp in single query | E2E: status reflects heartbeat |

---

## Detailed Hypothesis Analysis

### H1: Batch Ingest Idempotency

**Risk:** If idempotency is not enforced at the database level, network retries or user double-clicks could create duplicate time entries.

**Mitigation:**
1. Add `@@unique([kioskDeviceId, idempotencyKey])` to KioskEvent model
2. Before creating time entry, check if KioskEvent with same key exists
3. If exists, return stored result without creating new entry

**Test:**
```typescript
// Send batch with key "abc123"
const res1 = await POST('/events/batch', { events: [{ idempotencyKey: 'abc123', ... }] });
// Re-send same batch
const res2 = await POST('/events/batch', { events: [{ idempotencyKey: 'abc123', ... }] });
// Both should return same result, only 1 time entry created
expect(res1.body.results[0].status).toBe(res2.body.results[0].status);
```

---

### H2: Event Ordering Constraints

**Risk:** Offline queue may send events out of order (e.g., clock-out before clock-in).

**Mitigation:**
1. Server validates sequence based on user's current clock state
2. Reject illegal sequences with explicit code: `SEQUENCE_VIOLATION`
3. Return deterministic results per event

**Test:**
```typescript
// Send clock-out for user not clocked in
const res = await POST('/events/batch', { events: [
  { type: 'CLOCK_OUT', idempotencyKey: 'out1', pin: '1234' }
]});
expect(res.body.results[0].status).toBe('REJECTED');
expect(res.body.results[0].code).toBe('NOT_CLOCKED_IN');
```

---

### H3: No Timers in Session Logic

**Risk:** Using setTimeout/setInterval for session expiry causes Jest open handles.

**Mitigation:**
1. Session "expired" is computed by query: `WHERE NOW() - lastHeartbeatAt > threshold`
2. Health status computed at query time, not background job
3. No cleanup timers, no polling intervals

**Verification:**
```typescript
// Test exits without --forceExit
// No open handle warnings in output
```

---

### H4: PIN Security

**Risk:** Raw PIN stored in logs, database, or error messages.

**Mitigation:**
1. KioskPinAttempt stores `pinMasked` (e.g., "**34") or `pinHashPrefix`
2. Audit logs never include raw PIN
3. API error messages reference "invalid PIN" without echoing value

**Code Review Checklist:**
- [ ] No `pin` field stored directly
- [ ] No `console.log(pin)`
- [ ] Error messages don't include PIN value

---

### H5: Export Hash Cross-Platform

**Risk:** Windows CRLF vs Unix LF causes different hash.

**Mitigation:**
1. Normalize all line endings to LF before hash computation
2. Use stable column ordering
3. Include BOM for UTF-8 compatibility

**Test:**
```typescript
const csv = await GET('/export/kiosk-events');
const hash = crypto.createHash('sha256')
  .update(csv.body.replace(/\r\n/g, '\n'))
  .digest('hex');
expect(csv.headers['x-nimbus-export-hash']).toBe(hash);
```

---

### H6: Rate Limit Fairness

**Risk:** Legitimate users blocked after device network issues cause retry storms.

**Mitigation:**
1. Rate limit uses sliding window (queries last N minutes)
2. Successful attempts count toward limit but don't penalize
3. Window slides forward naturally via timestamp

**Test:**
```typescript
// 5 invalid attempts, then 1 valid
// Should allow valid attempt if within window
```

---

### H7: Audit Completeness

**Risk:** Missing context in audit logs makes forensics impossible.

**Mitigation:**
1. All audit calls include: `orgId`, `branchId`, `kioskDeviceId`, `userId` (if known)
2. Batch events include `idempotencyKey` in metadata
3. Rejection reasons include `rejectCode`

**Code Review Checklist:**
- [ ] KIOSK_EVENT_BATCH_RECEIVED includes eventCount
- [ ] KIOSK_EVENT_ACCEPTED includes timeEntryId
- [ ] KIOSK_EVENT_REJECTED includes rejectCode

---

### H8: UI Queue Flush

**Risk:** Browser localStorage queue grows unbounded if sync fails.

**Mitigation:**
1. Queue size limit (e.g., 100 events)
2. Clear queue on successful batch response
3. Visible queue count in UI
4. Manual "Sync Now" button (no auto-sync timers)

**UI Test:**
```typescript
// Mock API failure, add event to queue
expect(getQueueCount()).toBe(1);
// Mock API success, trigger sync
await clickSync();
expect(getQueueCount()).toBe(0);
```

---

### H9: Batch Atomicity

**Risk:** Partial batch processing leaves inconsistent state.

**Mitigation:**
1. Each batch processed in single transaction
2. All events recorded regardless of individual accept/reject
3. Batch status tracks overall success

**Test:**
```typescript
// Batch with 3 events, 1 invalid
// All 3 should have KioskEvent records
// Invalid one has status: REJECTED
```

---

### H10: Health Status Consistency

**Risk:** Race between heartbeat and health query shows wrong status.

**Mitigation:**
1. Health query uses single timestamp: `NOW()`
2. Status computed from `lastHeartbeatAt` in same query
3. No caching of health status

**Test:**
```typescript
// Send heartbeat
await POST('/heartbeat');
// Immediately check health
const health = await GET('/devices/health');
expect(health.body[0].status).toBe('ONLINE');
```

---

## Implementation Order

1. **Schema changes** (KioskEvent, KioskEventIngest, policy fields)
2. **Batch ingest service** (with idempotency, H1)
3. **Ordering validation** (H2)
4. **Health service** (computed status, H3)
5. **Fraud service** (rate limiting extension, H6)
6. **Audit integration** (H7)
7. **Export service** (hash normalization, H5)
8. **Web UI queue** (H8)

---

## Success Criteria

All hypotheses validated through:
1. E2E tests with specific assertions
2. Code review checklist completion
3. No open handle warnings in test output
4. Cross-platform hash verification
