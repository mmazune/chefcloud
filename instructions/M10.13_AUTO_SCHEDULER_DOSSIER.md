# M10.13 Auto-Scheduler Feature Dossier

## Overview

M10.13 extends M10.12 Workforce Planning by adding an enterprise-grade **Auto-Scheduler** that transforms StaffingPlan suggestions (hourly headcount by role) into actual ScheduledShift rows.

## Target Architecture

### Core Components

1. **AutoScheduleRun** - Tracks each generation attempt with:
   - inputsHash for deterministic idempotency
   - status workflow: DRAFT → APPLIED or VOID
   - Links to source StaffingPlan

2. **AutoScheduleSuggestion** - Shift blocks generated by algorithm:
   - roleKey, startAt, endAt, headcount
   - candidateUserIds (availability-aware hints)
   - score (optional prioritization)

3. **Auto-Scheduler Algorithm** - Deterministic greedy approach:
   - Converts hourly demand → shift blocks (4-8h)
   - Respects max shift policy
   - Produces availability-aware candidates

4. **Apply Flow** - Transactional shift creation:
   - Creates ScheduledShift rows from suggestions
   - Checks for existing shifts (safe rejection)
   - Records audit logs

## Reference Comparison

### Kimai (AGPL - STUDY ONLY)
- Kimai is primarily a time-tracking application, NOT a workforce planning/auto-scheduling tool
- No automatic shift generation from demand forecasts
- No staffing plan → shift conversion workflow
- Manual timesheet entry focus
- **Conclusion**: Kimai does NOT provide parity reference for auto-scheduling

### Internal Nimbus Standards
- M10.12: StaffingPlan/StaffingPlanLine models for demand
- M10.11: WorkforceAvailability for candidate filtering
- M10.1: ScheduledShift model for output
- DATA_PERSISTENCE_AND_CONSISTENCY_STANDARD.md: Transaction patterns
- E2E_TESTING_STANDARD.md: Test requirements

## Feature Comparison Matrix

| Feature | Kimai | Nimbus M10.13 Target | Evidence |
|---------|-------|---------------------|----------|
| Auto-generate shifts from demand | ❌ Not supported | ✅ REQUIRED | Algorithm + Apply flow |
| Deterministic idempotent generation | N/A | ✅ REQUIRED | inputsHash SHA256 |
| Availability-aware candidates | N/A | ✅ REQUIRED | M10.11 integration |
| Safe apply with conflict detection | N/A | ✅ REQUIRED | Reject if shifts exist |
| Variance impact reporting | N/A | ✅ REQUIRED | Before/after metrics |
| Residual alerts generation | N/A | ✅ REQUIRED | M10.12 StaffingAlert |
| RBAC enforcement | N/A | ✅ REQUIRED | L4+ apply, L3+ view |
| Multi-branch correctness | N/A | ✅ REQUIRED | Scoping on all queries |

## Algorithm Design (Deterministic Greedy)

### Input
- StaffingPlanLine rows: { hour: 0-23, roleKey, suggestedHeadcount }
- Branch timezone
- WorkforcePolicy (maxShiftMinutes)
- WorkforceAvailability + Exceptions

### Output
- AutoScheduleSuggestion rows: { roleKey, startAt, endAt, headcount, candidateUserIds }

### Algorithm Steps
1. **Load demand**: Group StaffingPlanLine by roleKey
2. **Create shift blocks**: For each role:
   - Start from first hour with demand > 0
   - Extend block up to 8h (or policy max) while demand exists
   - Record headcount as max demand within block
   - Repeat until all demand covered
3. **Calculate candidates**: For each suggestion:
   - Find users with roleLevel matching roleKey
   - Filter by availability: check WorkforceAvailability covers block
   - Exclude users with blocking WorkforceAvailabilityException
4. **Compute inputsHash**: SHA256 of canonicalized JSON (sorted keys)
5. **Idempotency check**: If run exists with same hash, return it

### Timezone Handling
- Store startAt/endAt as UTC timestamps
- Calculate from branch timezone + date + hour
- Ensure DST transitions handled correctly

## API Endpoints

| Method | Path | Description | RBAC |
|--------|------|-------------|------|
| POST | /workforce/planning/auto-schedule/generate | Create/return run + suggestions | L4+ |
| GET | /workforce/planning/auto-schedule | Get latest run for date | L3+ |
| POST | /workforce/planning/auto-schedule/:runId/apply | Apply suggestions → shifts | L4+ |
| POST | /workforce/planning/auto-schedule/:runId/void | Mark run as VOID | L4+ |
| GET | /workforce/planning/auto-schedule/:runId/impact | Get variance impact report | L3+ |

## Database Schema

```prisma
enum AutoScheduleRunStatus {
  DRAFT
  APPLIED
  VOID
}

model AutoScheduleRun {
  id               String                @id @default(cuid())
  orgId            String
  branchId         String
  date             DateTime              @db.Date
  timezone         String
  staffingPlanId   String
  inputsHash       String                // SHA256 of canonicalized inputs
  algorithmVersion String                @default("v1.0")
  status           AutoScheduleRunStatus @default(DRAFT)
  generatedAt      DateTime              @default(now())
  appliedAt        DateTime?
  appliedById      String?
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt

  org          Org                     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch       Branch                  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  staffingPlan StaffingPlan            @relation(fields: [staffingPlanId], references: [id], onDelete: Cascade)
  appliedBy    User?                   @relation("RunApplier", fields: [appliedById], references: [id], onDelete: SetNull)
  suggestions  AutoScheduleSuggestion[]

  @@unique([orgId, branchId, date, inputsHash])
  @@index([orgId, branchId, date])
  @@index([status])
}

model AutoScheduleSuggestion {
  id               String   @id @default(cuid())
  runId            String
  roleKey          String
  startAt          DateTime
  endAt            DateTime
  headcount        Int
  candidateUserIds Json?    // string[] hint
  score            Int?
  createdAt        DateTime @default(now())

  run AutoScheduleRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId, roleKey])
}
```

## UI Components

### /workforce/auto-scheduler.tsx
- Branch selector + date picker
- Generate button → calls POST /generate
- Apply button → calls POST /apply (L4+ only)
- Void button → calls POST /void (L4+ only)
- Suggestions table: role, start, end, headcount, candidates count
- Impact display: before/after variance
- Alerts summary: residual gaps

## Acceptance Criteria Mapping

| AC | Description | Test Strategy |
|----|-------------|---------------|
| AC-01 | Deterministic idempotent generation | E2E: 2 calls → same runId |
| AC-02 | Suggestions cover demand | E2E: verify suggestion count/coverage |
| AC-03 | Availability-aware candidates | E2E: blocked user excluded |
| AC-04 | Apply creates shifts transactionally | E2E: verify shift count |
| AC-05 | Apply fails if shifts exist | E2E: 409 response |
| AC-06 | Impact endpoint shows variance | E2E: verify metrics |
| AC-07 | Residual alerts generated | E2E: verify alerts created |
| AC-08 | Multi-branch correctness | E2E: branchA != branchB |
| AC-09 | Timezone correctness | E2E: verify startAt/endAt |
| AC-10 | No-hang compliance | E2E: test exits within 30s |
