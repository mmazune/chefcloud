# M10.21 Hypotheses Document

**Feature:** Kiosk Timeclock + Device Enrollment + Fraud Controls  
**Date:** 2024  
**Standard:** instructions/E2E_NO_HANG_STANDARD.md

---

## Hypothesis Validation Checklist

Each hypothesis must be validated via code inspection or test before implementation.

---

## H1: PIN Lookup Leaks Cross-Org Users

**Risk:** If the PIN lookup query is not scoped to `orgId`, an attacker could potentially discover users from other organizations by trying PINs on a kiosk enrolled in their org.

**Root Cause:** Missing `WHERE orgId = ?` in the user lookup query.

**Mitigation:**
```typescript
// WRONG - leaks cross-org users
const user = await prisma.client.user.findFirst({
  where: { pinHash: { not: null } },
});
await AuthHelpers.verifyPin(user.pinHash, inputPin);

// CORRECT - org-scoped lookup
const users = await prisma.client.user.findMany({
  where: { 
    orgId: session.device.orgId,  // From enrolled device
    pinHash: { not: null },
    isActive: true,
  },
});
// Then verify PIN against each candidate
for (const user of users) {
  if (await AuthHelpers.verifyPin(user.pinHash!, pin)) {
    return user;
  }
}
return null;
```

**Test:** E2E test that creates users in two orgs with same PIN, verifies kiosk in org A cannot find user from org B.

**Status:** [ ] Validated

---

## H2: Device Secret Rotation Does Not Invalidate Old Secrets

**Risk:** When rotating a device secret, if the old hash is still stored or cached, the old secret might continue to work.

**Root Cause:** Incomplete rotation that doesn't overwrite `secretHash`.

**Mitigation:**
```typescript
async rotateSecret(deviceId: string) {
  const newSecret = crypto.randomBytes(32).toString('hex');
  const newHash = await AuthHelpers.hashPassword(newSecret);
  
  // Transaction: update hash + invalidate all sessions
  await this.prisma.client.$transaction([
    this.prisma.client.kioskDevice.update({
      where: { id: deviceId },
      data: { secretHash: newHash },
    }),
    this.prisma.client.kioskDeviceSession.updateMany({
      where: { kioskDeviceId: deviceId, endedAt: null },
      data: { endedAt: new Date(), endedReason: 'ROTATED' },
    }),
  ]);
  
  return { plaintextSecret: newSecret }; // One-time return
}
```

**Test:** E2E test that rotates secret, then tries old secret → should fail.

**Status:** [ ] Validated

---

## H3: Rate-Limit Implementation Introduces Open Handles (Timers)

**Risk:** Using `setInterval()` or `setTimeout()` for rate limiting causes Jest tests to hang due to unclosed timers.

**Root Cause:** Common rate-limiting patterns use timers for sliding window cleanup.

**Mitigation:** Use DB-based sliding window count with no timers:
```typescript
async checkPinRateLimit(orgId: string, kioskDeviceId: string): Promise<boolean> {
  const windowStart = new Date(Date.now() - 60_000); // 1 minute ago
  
  const recentAttempts = await this.prisma.client.kioskPinAttempt.count({
    where: {
      kioskDeviceId,
      attemptedAt: { gte: windowStart },
    },
  });
  
  const policy = await this.prisma.client.workforcePolicy.findUnique({
    where: { orgId },
  });
  const limit = policy?.kioskPinRateLimitPerMinute ?? 5;
  
  return recentAttempts < limit;
}

// Record attempt (regardless of success)
async recordPinAttempt(data: {
  orgId: string;
  branchId: string;
  kioskDeviceId: string;
  pin: string; // Store masked (last 2 chars only)
  success: boolean;
  userId?: string;
  ipAddress?: string;
}) {
  await this.prisma.client.kioskPinAttempt.create({
    data: {
      orgId: data.orgId,
      branchId: data.branchId,
      kioskDeviceId: data.kioskDeviceId,
      pin: `**${data.pin.slice(-2)}`, // Mask first chars
      success: data.success,
      userId: data.userId,
      ipAddress: data.ipAddress,
    },
  });
}
```

**Test:** Verify no jest timers warning; E2E test that exceeds rate limit → should be blocked.

**Status:** [ ] Validated

---

## H4: requireKioskForTimeclock Breaks Manager/Admin Flows

**Risk:** Enabling `requireKioskForTimeclock` could block managers (L3+) or admins (L4+) from clocking in via normal API for legitimate admin purposes.

**Root Cause:** Policy enforcement without role-based bypass.

**Mitigation:**
```typescript
// In WorkforceTimeclockService.clockIn()
async clockIn(data: { userId: string; orgId: string; branchId: string; ... }) {
  const policy = await this.getPolicy(data.orgId);
  
  if (policy.requireKioskForTimeclock) {
    // Check if this is a kiosk request (has kioskDeviceId)
    if (!data.kioskDeviceId) {
      // Allow L4+ to bypass for admin purposes
      const user = await this.prisma.client.user.findUnique({
        where: { id: data.userId },
      });
      if (user && ROLE_LEVEL_MAP[user.roleLevel] < 4) {
        throw new ForbiddenException(
          'Kiosk timeclock is required. Please use the kiosk at your branch entrance.'
        );
      }
    }
  }
  // ... continue with clock-in
}
```

**Test:** Enable policy, verify L2 blocked via API, L4 allowed via API.

**Status:** [ ] Validated

---

## H5: Geofence Enforcement Incorrectly Blocks When Geo Metadata Optional

**Risk:** When `requireGeofenceForKiosk` is true but kiosk location is not available, users get incorrectly blocked.

**Root Cause:** Kiosk devices are fixed-location; they shouldn't require GPS from the device itself.

**Mitigation:** Use branch geofence center as the kiosk's location:
```typescript
async clockInViaKiosk(sessionId: string, pin: string) {
  const session = await this.getSession(sessionId);
  const device = session.kioskDevice;
  
  // Get policy
  const policy = await this.getPolicy(device.orgId);
  
  if (policy.requireGeofenceForKiosk) {
    // Use branch geofence center as kiosk location
    const geofence = await this.prisma.client.branchGeoFence.findUnique({
      where: { branchId: device.branchId },
    });
    
    if (geofence && geofence.enabled) {
      // For kiosk, we assume device is at branch center (fixed installation)
      // Log event but don't block (device is pre-enrolled at branch)
      await this.geoFenceService.logEvent(
        device.orgId,
        device.branchId,
        userId,
        'ALLOWED',
        'CLOCK_IN',
        { lat: geofence.centerLat, lng: geofence.centerLng },
      );
    }
  }
  // ... continue with clock-in
}
```

**Alternative:** If kiosk has GPS capability, accept coordinates in request but fall back to branch center.

**Test:** Enable both policies, verify kiosk clock-in succeeds with audit trail.

**Status:** [ ] Validated

---

## H6: CSV Export Hash Mismatch (BOM/Line Endings)

**Risk:** Export hash verification fails due to inconsistent BOM or line ending handling.

**Root Cause:** Different handling between server generation and client verification.

**Mitigation:** Follow existing M10.20 export pattern:
```typescript
// From geofence-reporting.service.ts (verified working)
const BOM = '\uFEFF';
const lines: string[] = [header, ...rows];
const content = lines.join('\r\n'); // Windows line endings
const contentWithBom = BOM + content;

// Hash excludes BOM for verification
const hash = crypto.createHash('sha256').update(content).digest('hex');
const trailer = `# SHA-256: ${hash}`;

return contentWithBom + '\r\n' + trailer;
```

**Test:** Export CSV, manually verify hash with sha256sum (excluding BOM and trailer).

**Status:** [ ] Validated

---

## H7: Kiosk Endpoints Allow Branch Spoofing

**Risk:** If kiosk clock-in endpoints accept `branchId` from the client, an attacker could spoof a different branch.

**Root Cause:** Trusting client-provided branchId instead of deriving from enrolled device.

**Mitigation:** NEVER accept branchId from kiosk client:
```typescript
// Public kiosk controller
@Post(':publicId/clock-in')
async clockIn(
  @Param('publicId') publicId: string,
  @Headers('x-kiosk-session') sessionId: string,
  @Body() body: { pin: string },  // NO branchId accepted
) {
  const session = await this.sessionService.validateSession(sessionId);
  
  // Derive branchId from enrolled device
  const branchId = session.kioskDevice.branchId;  // ALWAYS from device
  
  return this.timeclockService.clockIn({
    sessionId,
    pin: body.pin,
    branchId,  // From device, not client
  });
}
```

**Test:** Try to send branchId in request body → should be ignored, use device's branch.

**Status:** [ ] Validated

---

## H8: Tests Hang Due to Unclosed App

**Risk:** E2E tests hang because NestJS app is not properly closed in afterAll.

**Root Cause:** Missing `await app.close()` or unclosed database connections.

**Mitigation:** Follow E2E_NO_HANG_STANDARD.md pattern:
```typescript
afterAll(async () => {
  await traceSpan('afterAll', async () => {
    trace('cleaning up test data');
    
    if (prisma) {
      try {
        // Clean test data
        await prisma.client.kioskClockEvent.deleteMany({ where: { orgId } });
        await prisma.client.kioskPinAttempt.deleteMany({ where: { orgId } });
        await prisma.client.kioskDeviceSession.deleteMany({ 
          where: { kioskDevice: { orgId } } 
        });
        await prisma.client.kioskDevice.deleteMany({ where: { orgId } });
      } catch (e) {
        trace('Cleanup error', { error: (e as Error).message });
      }
    }
    
    trace('closing app');
    await withTimeout(cleanup(app), { ms: 15_000, label: 'cleanup' });
    trace('afterAll complete');
  });
});
```

**Test:** Run E2E test with `--detectOpenHandles`, verify clean exit.

**Status:** [ ] Validated

---

## Validation Summary

| Hypothesis | Risk Level | Mitigation | Test Required |
|------------|-----------|------------|---------------|
| H1 | HIGH | Org-scoped PIN lookup | Cross-org leak test |
| H2 | HIGH | Atomic rotation + session invalidation | Old secret rejection test |
| H3 | MEDIUM | DB-based sliding window | Rate limit exceeded test |
| H4 | MEDIUM | L4+ bypass for admin | Policy + role test |
| H5 | LOW | Use branch center for kiosk | Geofence + kiosk test |
| H6 | LOW | Follow M10.20 export pattern | Hash verification test |
| H7 | HIGH | Derive branchId from device | Spoofing rejection test |
| H8 | MEDIUM | Follow E2E_NO_HANG_STANDARD | Clean exit test |

---

## Implementation Order

Based on risk analysis, implement in this order:

1. **H7** (Branch spoofing) - Architectural decision, affects all endpoints
2. **H1** (Cross-org leak) - Security critical, affects PIN lookup
3. **H2** (Secret rotation) - Security critical, affects device management
4. **H3** (Rate limiting) - No timers, affects PIN validation
5. **H4** (Policy bypass) - Business logic, affects policy enforcement
6. **H8** (Test cleanup) - DevEx, affects all tests
7. **H5** (Geofence kiosk) - Integration, affects geofence
8. **H6** (Export hash) - Minor, copy from M10.20
