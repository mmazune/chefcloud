# M11.4 Hypotheses â€” Recipes/BOM + POS Depletion

## Pre-Implementation Risk Assessment

| ID | Hypothesis | Confidence | Failure Mode | Mitigation |
|----|------------|------------|--------------|------------|
| H1 | Order depletion double-posts due to retries (idempotency failure) | HIGH | Payment webhook retries, POS retry on timeout, job rerun | UNIQUE(orgId, orderId) on OrderInventoryDepletion; check status=POSTED before creating ledger entries; return isAlreadyPosted=true |
| H2 | Depletion posts to wrong branch/location (branch scoping bug) | HIGH | Cross-tenant leakage, wrong inventory location decremented | Verify locationId belongs to order.branchId; verify orgId matches throughout; deterministic location resolution with explicit fallback chain |
| H3 | UOM conversion rounding drift causes ingredient totals mismatch | MEDIUM | Accumulated rounding errors over many orders cause inventory discrepancy | Store qtyBase on RecipeLine (pre-computed, not calculated at depletion time); use Decimal(12,4) precision; document rounding rules |
| H4 | Negative stock policy breaks POS flow (UX regression) | HIGH | Server returns error, POS cannot close order, customer stuck | Use Option A: allow order completion, mark depletion as FAILED with INSUFFICIENT_STOCK; never block order close |
| H5 | Recipe updates break historical depletion reproducibility | MEDIUM | Updated recipe causes different ingredient calculation for same order | Depletion uses recipe state at posting time; historical ledger entries are immutable; for audit, query by sourceId=orderId |
| H6 | Export hash mismatch on Windows (BOM/newline normalization) | MEDIUM | CRLF vs LF causes different hash; repeated exports produce different hashes | Use explicit \n in CSV generation; compute hash after BOM prefix; consistent ordering by createdAt ASC, id ASC |
| H7 | RBAC allows L2 to modify recipes (privilege escalation) | HIGH | L2 user can create/update recipes without proper authorization | Explicit @Roles('L3', 'L4', 'L5') decorators on write endpoints; E2E test verifying 403 for L2 user |
| H8 | Tests hang due to leftover app/server/open handles | HIGH | Jest --detectOpenHandles shows unclosed connections; CI times out | Proper app.close() in afterAll; no setInterval/setTimeout without cleanup; await all promises before teardown |
| H9 | Depletion location not found causes silent skip | MEDIUM | No location in branch, depletion silently skipped, inventory never decremented | Explicit FAILED status with LOCATION_NOT_FOUND errorCode; never silently skip; surface in depletions list |
| H10 | Order without recipe items causes error or crash | LOW | Order contains only non-recipe items; depletion processing fails | Handle gracefully: set status=SKIPPED if no items have recipes; log informational message; return success |
| H11 | Concurrent order closures cause race condition on same item | MEDIUM | Two orders deplete same ingredient simultaneously, one fails negative check incorrectly | Use Prisma transaction with SELECT FOR UPDATE pattern on ledger aggregate; or handle at application level with retry |
| H12 | RecipeLine qtyBase not updated when UOM conversion changes | MEDIUM | Admin updates UOM conversion factor, existing recipe lines have stale qtyBase | Document that qtyBase is computed at line creation; provide "recalculate" endpoint for admin if needed |

---

## Validation Approach

### H1: Idempotency
- E2E test: Call closeOrder twice with same orderId; assert ledger entry count unchanged on second call
- E2E test: Check response.isAlreadyPosted === true on second call

### H2: Branch Scoping
- E2E test: Create order in Branch A, attempt depletion with location from Branch B; assert failure
- E2E test: Verify all ledger entries have correct branchId matching order.branchId

### H3: UOM Conversion
- E2E test: Create recipe with non-base UOM; verify qtyBase stored correctly
- E2E test: After depletion, verify ingredient qty matches expected calculation

### H4: Negative Stock
- E2E test: Set up ingredient with 5 units; sell 10 units; assert depletion status=FAILED, errorCode=INSUFFICIENT_STOCK
- E2E test: Verify ledger unchanged (no partial depletion)

### H5: Historical Reproducibility
- Document: Ledger entries are immutable; sourceId links to order
- E2E test: Update recipe; old orders still queryable by orderId

### H6: Export Hash
- E2E test: Call export twice; assert same X-Nimbus-Export-Hash header
- E2E test: Verify BOM present (first char 0xFEFF)

### H7: RBAC
- E2E test: L2 token calls POST /inventory/recipes; assert 403
- E2E test: L3 token calls same endpoint; assert 201

### H8: Test Cleanup
- All tests use proper afterAll with app.close()
- Run with --detectOpenHandles to verify no leaks
- No --forceExit allowed

### H9: Location Not Found
- E2E test: Remove all locations from branch; attempt depletion; assert status=FAILED, errorCode=LOCATION_NOT_FOUND

### H10: No Recipe Items
- E2E test: Close order with items that have no recipe; assert status=SKIPPED, no error

### H11: Concurrency
- Design: Use transaction isolation; document expected behavior under load
- Optional stress test (not in M11.4 scope)

### H12: Stale qtyBase
- Document: qtyBase computed at line creation; admin must re-add lines if conversions change
