# M12.3 Inventory Period Controls v3 — Feature Dossier

> **Version**: 1.0  
> **Created**: 2026-01-07  
> **Status**: Planning → Implementation  
> **Prior Milestone**: M12.2 at commit `c8f2596`

---

## 1. Executive Summary

M12.3 makes inventory period controls enterprise-grade by:
1. Supporting effective-dated inventory postings (`effectiveAt`) without mutating `createdAt`
2. Enforcing period locks across **every** inventory write path
3. Providing operational automation hooks + reporting for reliable closes

---

## 2. Feature-Level Comparison (Deep)

### 2.1 Reference: InvenTree (MIT, ADAPT allowed)

| InvenTree Concept | Behavior | Nimbus M12.3 Target |
|-------------------|----------|---------------------|
| Stock History Date | InvenTree's `StockItemHistory` tracks `date` field separate from `created` timestamp. The `date` represents when the stock event logically occurred (e.g., receipt date, shipment date). | **ADOPT**: Add `effectiveAt` to `InventoryLedgerEntry` as business event date, distinct from `createdAt` (system timestamp). |
| Audit Trail | Every stock movement creates a `StockItemTracking` entry with user, timestamp, and old/new quantities. History is append-only. | **MAINTAIN**: Already have append-only ledger (M11.15). Enhance with `effectiveAt` for period boundary queries. |
| Stocktake Semantics | InvenTree stocktake adjustments are posted with the stocktake completion date, not real-time. Allows backdating within reason. | **ADOPT**: Stocktake `postLedgerEntries()` should use stocktake's `postedAt` as `effectiveAt`, not `now()`. |
| Period Locking | InvenTree does NOT have formal period locking (open-source version). | **DIFFERENTIATE**: Nimbus adds enterprise-grade period locking with L5 override + audit. |

**InvenTree Code Reference** (stock/models.py):
```python
class StockItemTracking(models.Model):
    date = models.DateTimeField(auto_now_add=False)  # Explicit event date
    created = models.DateTimeField(auto_now_add=True)  # System timestamp
```

### 2.2 Reference: Medusa (MIT, ADAPT allowed)

| Medusa Concept | Behavior | Nimbus M12.3 Target |
|----------------|----------|---------------------|
| Inventory Level Events | Medusa tracks inventory via `InventoryLevel` with `stocked_quantity`, `reserved_quantity`. Changes are event-sourced via `InventoryLevelUpdatedEvent`. | **ADAPT**: Our ledger is already event-sourced. Events should carry `effectiveAt`. |
| Event Modeling | Medusa uses domain events (`InventoryItemCreatedEvent`, etc.) with timestamps. Events are immutable. | **MAINTAIN**: Already have immutable ledger entries. |
| Reservation Flow | Reservations are created/released with explicit timestamps. Order date drives reservation timing. | **ADOPT**: Depletion `effectiveAt` should derive from order/sale `effectiveAt`. |

**Medusa Primitives** (packages/inventory):
- `InventoryItem` → item definition
- `InventoryLevel` → location-specific stock levels
- `ReservationItem` → pending allocations

### 2.3 Reference: Internal Kill Bill / Bigcapital Patterns

| Pattern | Behavior | Nimbus M12.3 Target |
|---------|----------|---------------------|
| Locked Period Rejection | Finance milestones (M10.6, M10.8) reject GL postings into closed periods with HTTP 403 and machine-readable code. | **ADOPT**: `INVENTORY_PERIOD_LOCKED` code on 403 response. |
| Override Semantics | L5 (OWNER/ADMIN) can override with explicit reason (≥10 chars). Override is logged as audit event. | **ADOPT**: `InventoryPeriodEvent` type `OVERRIDE_USED` with metadata. |
| Audit Trail | Every override creates a `LockedPeriodOverride` or equivalent event with actor, timestamp, reason, affected entity. | **ADOPT**: Store `{ actorId, endpoint, referenceType, referenceId }` in event metadata. |

**Existing Implementation** (from M12.2 inventory-periods.service.ts):
```typescript
// L5 override endpoint exists but needs enhancement
async logOverrideUsage(orgId, userId, periodId, reason, actionType, entityType, entityId)
```

---

## 3. Feature Scope Detail

### A) Effective-Dated Ledger Entries

**Schema Change**:
```prisma
model InventoryLedgerEntry {
  // ... existing fields ...
  effectiveAt DateTime @default(now()) // Business event date
  // createdAt remains system timestamp
}
```

**Rules**:
1. `effectiveAt` defaults to `createdAt` if not provided
2. Period membership uses `effectiveAt` (NOT `createdAt`)
3. Migration backfills: `effectiveAt = createdAt` for all existing rows
4. All ledger-creating services pass `effectiveAt` from business event date

**Services to Update**:
- `inventory-ledger.service.ts` → `createEntry()` accepts `effectiveAt`
- `inventory-goods-receipt.service.ts` → uses receipt date
- `inventory-waste.service.ts` → uses waste date
- `inventory-stocktake.service.ts` → uses stocktake postedAt
- `inventory-transfers.service.ts` → uses transfer date
- `inventory-production.service.ts` → uses production date
- `inventory-depletion.service.ts` → uses sale/order effectiveAt

### B) Full Period-Lock Coverage

**Enforce Period Lock On**:
| Path | Service | Method |
|------|---------|--------|
| Adjustments | `inventory.service.ts` | `applyAdjustment()` |
| Goods Receipts | `inventory-goods-receipt.service.ts` | `postReceipt()`, `voidReceipt()` |
| Transfers | `inventory-transfers.service.ts` | `shipTransfer()`, `receiveTransfer()` |
| Waste | `inventory-waste.service.ts` | `postWaste()`, `voidWaste()` |
| Depletion | `inventory-depletion.service.ts` | `runDepletion()`, `retryDepletion()` |
| Production | `inventory-production.service.ts` | `postProduction()`, `voidProduction()` |
| Stocktake | `inventory-stocktake.service.ts` | `postCountResults()`, `voidStocktake()` |
| Lot Allocations | `inventory-lots.service.ts` | `allocateLot()`, `deallocateLot()` |
| Vendor Returns | `inventory-vendor-returns.service.ts` | `postReturn()`, `voidReturn()` |
| Recalls | `inventory-recalls.service.ts` | `postRecall()` |
| Fast Ops | `inventory-fast-ops.service.ts` | all quick-adjust methods |

**Enforcement Pattern**:
```typescript
async enforcePeriodLock(orgId: string, branchId: string, effectiveAt: Date): Promise<void> {
  const period = await this.findPeriodByEffectiveDate(orgId, branchId, effectiveAt);
  if (period?.status === 'CLOSED') {
    throw new HttpException({
      statusCode: 403,
      error: 'Forbidden',
      code: 'INVENTORY_PERIOD_LOCKED',
      message: `Cannot post to closed period ${period.id} (${period.startDate} - ${period.endDate})`,
      periodId: period.id,
    }, HttpStatus.FORBIDDEN);
  }
}
```

**L5 Override Flow**:
1. L5 user calls override endpoint with `reason` (≥10 chars)
2. System creates `InventoryPeriodEvent` type `OVERRIDE_USED`
3. Returns one-time override token (or flag) valid for single operation
4. Original operation retried with override context
5. Ledger entry created with `overrideEventId` reference

### C) Close Pack Accuracy Improvements

**Reconciliation Export Updates**:
- All queries use `effectiveAt >= startDate AND effectiveAt <= endDate`
- Add "diff summary" to close pack:
  - Totals per category (RECEIPTS, COGS, WASTE, VARIANCE)
  - Row counts per export
  - Individual hash + bundle hash (existing)
  - Pack integrity summary

### D) Close Ops Automation Hooks

**New Endpoints** (callable, NO cron/timers):
1. `POST /inventory/periods/:id/run-preclose` → runs checks, returns READY/BLOCKED/WARNING
2. `POST /inventory/periods/:id/generate-close-pack` → regenerates pack (idempotent)

**Optional Alerting** (if M11.12 alerts exist):
- Create `PERIOD_CLOSE_BLOCKED` alert type (idempotent)

### E) Web UI Enhancements

**Updates to `/inventory/period-close`**:
1. Display "Period boundaries use effective date" messaging
2. L5-only "Override Lock" action with reason prompt
3. Warning banner when override exists
4. Audit trail link to period events

---

## 4. Acceptance Criteria

| ID | Criterion | Test Coverage |
|----|-----------|---------------|
| A1 | `effectiveAt` stored on new ledger entries | E2E + unit |
| A2 | `effectiveAt` defaults to `createdAt` when not provided | E2E |
| A3 | Period membership queries use `effectiveAt` | E2E |
| B1 | Period lock blocks all inventory write paths | E2E per path |
| B2 | Rejection returns 403 with `INVENTORY_PERIOD_LOCKED` code | E2E |
| B3 | L5 override succeeds with reason ≥10 chars | E2E |
| B4 | Override creates `OVERRIDE_USED` event | E2E |
| C1 | Close pack totals use `effectiveAt` boundaries | E2E |
| C2 | Reconciliation exports are deterministic | E2E (hash) |
| D1 | `run-preclose` endpoint returns normalized output | E2E |
| D2 | `generate-close-pack` is idempotent | E2E |
| E1 | UI shows effective date messaging | UI test |
| E2 | Override button visible only to L5 | UI test |

---

## 5. Migration Strategy

1. Add `effectiveAt` column with default `now()` (non-breaking)
2. Backfill: `UPDATE inventory_ledger_entries SET effectiveAt = createdAt WHERE effectiveAt IS NULL`
3. Add index on `effectiveAt` for period queries
4. Update unique constraints if needed

---

## 6. Security Considerations

1. **Tenant Isolation**: All queries include `orgId` filter
2. **Branch Scoping**: Period locks are branch-scoped
3. **Override Audit**: Every override is logged with actor + reason
4. **Reason Validation**: Minimum 10 characters, sanitized for logging
5. **No Cross-Tenant Targeting**: Validate branchId belongs to orgId

---

## 7. Rollback Plan

1. `effectiveAt` column can be ignored if issues arise (queries fall back to `createdAt`)
2. Period lock enforcement is feature-flagged (can disable in emergency)
3. Override events are append-only (no data loss on rollback)
