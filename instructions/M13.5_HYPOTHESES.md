# M13.5 Hypotheses

**Milestone**: M13.5 POS Finalization v1  
**Date**: 2026-01-08

---

## Hypotheses (Pre-Implementation)

### H1: Partial payment allows cross-branch leakage if missing orgId/branchId filter
**Confidence**: 90%  
**Failure Mode**: User in Branch A can make payment on Branch B order if only orderId is checked.  
**Mitigation**: All payment operations must filter by `{ orderId, branch: { id: branchId, orgId } }` in transaction.  
**Test**: E2E test attempts cross-branch payment creation → 404.

### H2: Overpayment permitted due to stale dueCents computation (race)
**Confidence**: 85%  
**Failure Mode**: Two concurrent partial payments both read stale `paidCents`, both succeed, total exceeds order.  
**Mitigation**: Compute `dueCents` inside serializable transaction with SELECT FOR UPDATE or atomic check.  
**Test**: E2E test submits `amountCents > dueCents` → 400 OVERPAYMENT_NOT_ALLOWED.

### H3: Tip incorrectly counted toward dueCents (settlement invariant breach)
**Confidence**: 95%  
**Failure Mode**: `dueCents = orderTotal - (paidCents + tipCents)` would allow underpayment.  
**Mitigation**: Tips are stored separately; dueCents formula ignores tipCents entirely.  
**Test**: E2E creates payment with tip, verifies dueCents unchanged by tip amount.

### H4: Double capture creates duplicate "paid" and breaks totals
**Confidence**: 90%  
**Failure Mode**: Capture called twice adds to paidCents twice if not idempotent.  
**Mitigation**: Capture is idempotent (if already CAPTURED, return existing without incrementing).  
**Test**: E2E calls capture twice on same payment, verifies paidCents stable.

### H5: Refund math allows refunded > captured (negative net)
**Confidence**: 85%  
**Failure Mode**: Refund 2000 cents on payment with only 1000 captured → negative net.  
**Mitigation**: Validate `refundedCents + newRefund <= capturedCents` before proceeding.  
**Test**: E2E attempts refund exceeding captured → 400 REFUND_EXCEEDS_CAPTURED.

### H6: Z-report hash mismatch (BOM/line endings ordering on Windows)
**Confidence**: 80%  
**Failure Mode**: CSV generated with \r\n on Windows, hash differs from expected.  
**Mitigation**: Force LF line endings in export; consistent ordering by date/branch/category.  
**Test**: E2E exports twice, verifies identical X-Nimbus-Export-Hash.

### H7: PaymentStatus transitions regress KDS/Order lifecycle logic
**Confidence**: 75%  
**Failure Mode**: Adding `paymentStatus` enum breaks existing OrderStatus queries or migrations.  
**Mitigation**: `paymentStatus` is completely separate field; OrderStatus unchanged; no breaking queries.  
**Test**: E2E verifies KDS ticket creation still works after schema change.

### H8: UI tests hang due to polling/intervals or unclosed mocks
**Confidence**: 85%  
**Failure Mode**: Jest test hangs at end due to unclosed fetch intervals or query polling.  
**Mitigation**: Use `jest.useFakeTimers()`, cleanup intervals, no real network calls in smoke tests.  
**Test**: UI test suite completes in <30s with clean exit.

---

## Summary Table

| ID | Hypothesis | Confidence | Failure Mode | Validated |
|----|------------|------------|--------------|-----------|
| H1 | Cross-branch payment leakage | 90% | Branch A pays Branch B order | ⏳ |
| H2 | Overpayment race condition | 85% | Concurrent partials exceed total | ⏳ |
| H3 | Tip counted in dueCents | 95% | Settlement invariant broken | ⏳ |
| H4 | Double capture double-counts | 90% | paidCents inflated | ⏳ |
| H5 | Refund exceeds captured | 85% | Negative net payment | ⏳ |
| H6 | Z-report hash mismatch | 80% | Windows line ending issue | ⏳ |
| H7 | PaymentStatus breaks KDS | 75% | Order lifecycle regressed | ⏳ |
| H8 | UI test hangs | 85% | Open handles/intervals | ⏳ |

All hypotheses will be validated via E2E and UI tests.
