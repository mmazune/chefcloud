# M11.1 Inventory Foundation - Feature Comparison Dossier

## Executive Summary

This dossier documents the architectural decisions for M11.1 Inventory Foundation, drawing from reference implementations in:
- **InvenTree** (MIT License) - Python/Django-based inventory management
- **Medusa** (MIT License) - Node.js/TypeScript commerce platform

Both systems are MIT-licensed, allowing ADAPT (not copy-paste) of patterns.

## Reference System Analysis

### InvenTree Patterns

| Feature | InvenTree Implementation | ChefCloud Adaptation |
|---------|-------------------------|----------------------|
| Stock Location | `StockLocation` - hierarchical tree with MPTT | `InventoryLocation` - flat per-branch with parent pointer |
| Stock Item | `StockItem` with quantity field, mutates in place | Append-only `InventoryLedgerEntry`, derived on-hand |
| Stock Tracking | `StockItemTracking` - history with `tracking_type` enum | `InventoryLedgerEntry.reason` + `sourceType` |
| Stock Operations | `stocktake()`, `add_stock()`, `take_stock()` | `ledger.recordEntry()` with validation |
| History Codes | `StockHistoryCode` enum (STOCK_ADD=11, STOCK_REMOVE=12, STOCK_COUNT=10) | `LedgerEntryReason` enum |
| Batch/Serial | Supports both batch numbers and serial numbers | Existing `StockBatch` model retained |
| Unit Handling | Part-level units only | `UnitOfMeasure` + `UnitConversion` tables |

### Medusa Patterns

| Feature | Medusa Implementation | ChefCloud Adaptation |
|---------|----------------------|----------------------|
| Inventory Level | `InventoryLevel` - stocked_quantity + reserved_quantity + incoming_quantity | Derived from ledger SUM |
| Location Link | `location_id` references StockLocation module | `InventoryLocation.id` |
| Reservations | `ReservationItem` - line_item linked | Future: integrate with orders |
| Adjustment | `adjustInventory()` method | `inventory-adjustments.service.ts` |
| Available Qty | Computed: stocked - reserved | Computed from ledger |

## M11.1 Scope Mapping

### Scope A: Item Catalog & UOM

**New Models:**
1. `UnitOfMeasure` - org-scoped UOM definitions
2. `UnitConversion` - conversion factors between UOMs

**Adaptation:**
- InvenTree embeds units in Part model
- Medusa uses simple string units
- ChefCloud: Separate `UnitOfMeasure` table for multi-org support with conversions

### Scope B: Locations

**New Model:**
1. `InventoryLocation` - warehouse/storage locations per branch

**Adaptation:**
- InvenTree: Hierarchical tree
- Medusa: Flat with StockLocation module
- ChefCloud: Flat with parent pointer, branch-scoped

### Scope C: Stock Ledger (CRITICAL)

**New Model:**
1. `InventoryLedgerEntry` - APPEND-ONLY, immutable ledger

**Key Pattern (InvenTree `add_tracking_entry`):**
```python
def add_tracking_entry(self, entry_type, user, deltas=None, notes='', ...):
    if deltas is None:
        deltas = {}
    # Never modifies existing entries
    tracking_info = {...}
    StockItemTracking.objects.create(...)
```

**ChefCloud Adaptation:**
- `InventoryLedgerEntry` is INSERT-only, no UPDATE/DELETE
- `onHand` computed as `SUM(qty) WHERE itemId AND locationId AND branchId`
- `sourceType` and `sourceId` for traceability (ADJUSTMENT, COUNT, PURCHASE, SALE, WASTAGE)

### Scope D: Adjustments

**Pattern (InvenTree `stocktake`):**
```python
@transaction.atomic
def stocktake(self, count, user, **kwargs):
    # Records delta from current quantity to new count
    delta = count - self.quantity
    self.updateQuantity(count)
    self.add_tracking_entry(StockHistoryCode.STOCK_COUNT, user, ...)
```

**ChefCloud Adaptation:**
- Create `StockAdjustment` record
- Insert `InventoryLedgerEntry` with delta quantity
- Default: Reject if resulting on-hand < 0 (configurable per-org)

### Scope E: Cycle Counts

**Pattern (InvenTree):**
- Direct stocktake with `stocktake()` method
- Records `STOCK_COUNT` tracking type

**ChefCloud Adaptation:**
- `CountSession` with `status`: OPEN â†’ FINALIZED/CANCELLED
- Multiple `CountSessionLine` entries (item+location+countedQty)
- `finalizeCount()` is IDEMPOTENT - subsequent calls are no-op

### Scope F: API & UI

**Endpoints:**
- `GET /inventory/items` - list items (L2+)
- `POST /inventory/items` - create item (L3+)
- `GET /inventory/locations` - list locations (L2+)
- `POST /inventory/locations` - create location (L4+)
- `GET /inventory/on-hand` - get on-hand levels (L2+)
- `POST /inventory/adjustments` - create adjustment (L3+)
- `POST /inventory/counts` - create count session (L3+)
- `POST /inventory/counts/:id/finalize` - finalize count (L3+)

**Pages:**
- `/inventory/items` - item list + create
- `/inventory/locations` - location management
- `/inventory/on-hand` - on-hand report by location
- `/inventory/adjustments` - adjustment history

## Ledger Immutability Guarantee

### Database Constraints
```sql
-- No UPDATE trigger (app-level enforcement)
-- No DELETE allowed (soft-delete only)
CREATE INDEX idx_ledger_item_loc ON inventory_ledger_entries (item_id, location_id);
CREATE INDEX idx_ledger_branch ON inventory_ledger_entries (branch_id);
```

### Application Enforcement
1. No `UPDATE` or `DELETE` methods exposed in service
2. All quantity changes via `INSERT` only
3. Correction entries: Insert reversal entry, not modify original

### On-Hand Calculation
```typescript
async getOnHand(itemId: string, locationId: string, branchId: string): Promise<Decimal> {
  const result = await this.prisma.client.inventoryLedgerEntry.aggregate({
    where: { itemId, locationId, branchId },
    _sum: { qty: true },
  });
  return result._sum.qty ?? new Decimal(0);
}
```

## RBAC Matrix

| Permission | Level | Description |
|------------|-------|-------------|
| `inventory:read` | L2 | View items, locations, on-hand |
| `inventory:write` | L3 | Create/edit items, create adjustments |
| `inventory:admin` | L4 | Create/edit UOM, locations |

## Negative Stock Handling

**Default Behavior:** Reject adjustments that would result in negative stock

**Configuration:**
```typescript
// Organization-level setting
interface OrgInventorySettings {
  allowNegativeStock: boolean; // Default: false
}
```

**Implementation:**
```typescript
if (!allowNegativeStock) {
  const currentOnHand = await this.getOnHand(itemId, locationId, branchId);
  if (currentOnHand.plus(delta).lessThan(0)) {
    throw new BadRequestException('Adjustment would result in negative stock');
  }
}
```

## Count Session Idempotency

**Pattern:**
```typescript
async finalizeCount(sessionId: string): Promise<CountSession> {
  return this.prisma.client.$transaction(async (tx) => {
    const session = await tx.countSession.findUnique({ where: { id: sessionId } });
    
    // IDEMPOTENT: Already finalized? Return as-is
    if (session.status === 'FINALIZED') {
      return session;
    }
    
    // Generate ledger entries for each line
    for (const line of session.lines) {
      const currentOnHand = await this.getOnHand(line.itemId, line.locationId, session.branchId);
      const delta = line.countedQty.minus(currentOnHand);
      
      if (!delta.isZero()) {
        await tx.inventoryLedgerEntry.create({
          data: {
            itemId: line.itemId,
            locationId: line.locationId,
            branchId: session.branchId,
            qty: delta,
            reason: 'COUNT_ADJUSTMENT',
            sourceType: 'COUNT_SESSION',
            sourceId: sessionId,
          },
        });
      }
    }
    
    return tx.countSession.update({
      where: { id: sessionId },
      data: { status: 'FINALIZED', finalizedAt: new Date() },
    });
  });
}
```

## Export Hash Compatibility

**Pattern (from M10.22 kiosk-fraud.service.ts):**
```typescript
const hash = crypto.createHash('sha256').update(csvContent).digest('hex');
```

**Cross-platform Consideration:**
- Use `\r\n` line endings consistently on Windows
- BOM prefix for Excel compatibility
- Hash computed on final content AFTER line ending normalization

## Test Requirements

### E2E Tests (no-hang standard)
1. Use `testDbSuffix` per test file
2. Close PrismaService in `afterAll`
3. Use `testingUser` fixture pattern
4. 30s timeout for complex operations

### Unit Tests
1. Mock Prisma with `prismaStub`
2. Test ledger immutability (no UPDATE calls)
3. Test negative stock rejection
4. Test idempotent finalize

---

*Created: M11.1 STEP 1*
*Reference: InvenTree (MIT), Medusa (MIT)*
