# M10.21 Workforce Kiosk Timeclock Dossier

**Feature:** Kiosk Timeclock + Device Enrollment + Fraud Controls  
**Status:** Implementation Planning  
**Prerequisite:** M10.20 Geo-Fencing Enforcement (complete)

---

## Executive Summary

M10.21 adds a **restaurant-grade shared kiosk timeclock mode**—a tablet/device at the staff entrance that allows employees to clock in/out using a PIN, with secure device enrollment, fraud controls (rate limiting, geofence enforcement integration), and comprehensive reporting.

---

## Feature Groups

### A) Device Enrollment + Trust Model

| Capability | Description |
|------------|-------------|
| **KioskDevice model** | Enrolled devices with org/branch binding |
| **Secret hashing** | Argon2id (same as password hashing) for device secrets |
| **Secret rotation** | Rotate secret without deleting device |
| **Allowed IP CIDRs** | Optional IP allowlist for device authentication |
| **Device sessions** | Track active sessions with heartbeats |
| **Audit trail** | Log device create/rotate/disable events |

### B) Kiosk Timeclock API

| Endpoint | Auth | Description |
|----------|------|-------------|
| `POST /public/kiosk/:publicId/authenticate` | None + device secret | Validate device, start session |
| `POST /public/kiosk/:publicId/clock-in` | Device session | Clock in via PIN |
| `POST /public/kiosk/:publicId/clock-out` | Device session | Clock out via PIN |
| `POST /public/kiosk/:publicId/break/start` | Device session | Start break via PIN |
| `POST /public/kiosk/:publicId/break/end` | Device session | End break via PIN |
| `GET /public/kiosk/:publicId/status` | Device session | Get current clock status for PIN |
| `POST /public/kiosk/:publicId/heartbeat` | Device session | Keep session alive |

### C) Fraud Controls

| Control | Description |
|---------|-------------|
| **PIN rate limiting** | DB-based sliding window (no timers to avoid open handles) |
| **requireKioskForTimeclock** | Policy flag to require kiosk for clock operations |
| **requireGeofenceForKiosk** | Integrate M10.20 geofence checks even for kiosk mode |
| **Branch binding** | Derive branchId from enrolled device, never accept from client |
| **PIN format validation** | Strict format check (4-6 digits) |
| **Device IP validation** | Optional CIDR allowlist enforcement |

### D) Admin Management

| Endpoint | Auth | Description |
|----------|------|-------------|
| `POST /workforce/kiosk/devices` | L4+ | Create kiosk device (returns one-time secret) |
| `GET /workforce/kiosk/devices` | L4+ | List org kiosk devices |
| `GET /workforce/kiosk/devices/:id` | L4+ | Get device details |
| `PATCH /workforce/kiosk/devices/:id` | L4+ | Update device (name, enabled, allowedIpCidrs) |
| `DELETE /workforce/kiosk/devices/:id` | L4+ | Delete device |
| `POST /workforce/kiosk/devices/:id/rotate-secret` | L4+ | Rotate secret (returns new one-time secret) |

### E) Reporting

| Endpoint | Description |
|----------|-------------|
| `GET /workforce/reports/kiosk-kpis` | Kiosk usage KPIs (clock events, devices, sessions) |
| `GET /workforce/reports/export/kiosk-events` | CSV export with SHA-256 hash trailer |

---

## Prisma Schema Changes

### New Models

```prisma
model KioskDevice {
  id              String   @id @default(cuid())
  orgId           String
  branchId        String
  name            String   // "Front Entrance Tablet"
  publicId        String   @unique @db.VarChar(32) // Short public identifier for URL
  secretHash      String   // Argon2id hash of device secret
  enabled         Boolean  @default(true)
  allowedIpCidrs  String[] @default([]) // Optional IP allowlist
  lastSeenAt      DateTime?
  createdById     String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  org       Org     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  createdBy User?   @relation("KioskDeviceCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  sessions  KioskDeviceSession[]

  @@index([orgId])
  @@index([branchId])
  @@index([publicId])
  @@map("kiosk_devices")
}

model KioskDeviceSession {
  id              String   @id @default(cuid())
  kioskDeviceId   String
  startedAt       DateTime @default(now())
  endedAt         DateTime?
  endedReason     String?  // EXPIRED, ROTATED, MANUAL, HEARTBEAT_TIMEOUT
  lastHeartbeatAt DateTime @default(now())
  ipAddress       String?
  userAgent       String?
  metadata        Json?

  kioskDevice     KioskDevice @relation(fields: [kioskDeviceId], references: [id], onDelete: Cascade)

  @@index([kioskDeviceId])
  @@index([startedAt])
  @@map("kiosk_device_sessions")
}

model KioskPinAttempt {
  id              String   @id @default(cuid())
  orgId           String
  branchId        String
  kioskDeviceId   String
  pin             String   // Last 2 chars only (masked)
  success         Boolean
  userId          String?  // Only set if successful
  ipAddress       String?
  attemptedAt     DateTime @default(now())

  org           Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch        Branch      @relation(fields: [branchId], references: [id], onDelete: Cascade)
  kioskDevice   KioskDevice @relation(fields: [kioskDeviceId], references: [id], onDelete: Cascade)
  user          User?       @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([orgId, kioskDeviceId, attemptedAt])
  @@index([kioskDeviceId, attemptedAt])
  @@map("kiosk_pin_attempts")
}

model KioskClockEvent {
  id              String   @id @default(cuid())
  orgId           String
  branchId        String
  kioskDeviceId   String
  userId          String
  eventType       String   // CLOCK_IN, CLOCK_OUT, BREAK_START, BREAK_END
  timeEntryId     String?
  breakEntryId    String?
  geoBlocked      Boolean  @default(false)
  geoOverridden   Boolean  @default(false)
  ipAddress       String?
  createdAt       DateTime @default(now())

  org           Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch        Branch      @relation(fields: [branchId], references: [id], onDelete: Cascade)
  kioskDevice   KioskDevice @relation(fields: [kioskDeviceId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId, branchId, createdAt])
  @@index([kioskDeviceId, createdAt])
  @@index([userId, createdAt])
  @@map("kiosk_clock_events")
}
```

### WorkforcePolicy Updates

```prisma
model WorkforcePolicy {
  // ... existing fields ...
  
  // M10.21: Kiosk Controls
  requireKioskForTimeclock     Boolean @default(false) // Require kiosk for clock operations
  requireGeofenceForKiosk      Boolean @default(false) // Apply geofence even for kiosk
  kioskPinRateLimitPerMinute   Int     @default(5)     // Max PIN attempts per minute per device
  kioskSessionTimeoutMinutes   Int     @default(720)   // 12 hours default session timeout
}
```

---

## Audit Actions

Add to `WorkforceAuditAction` enum:

```typescript
// M10.21: Kiosk Device Management
KIOSK_DEVICE_CREATED = 'KIOSK_DEVICE_CREATED',
KIOSK_DEVICE_UPDATED = 'KIOSK_DEVICE_UPDATED',
KIOSK_DEVICE_DELETED = 'KIOSK_DEVICE_DELETED',
KIOSK_DEVICE_SECRET_ROTATED = 'KIOSK_DEVICE_SECRET_ROTATED',
KIOSK_DEVICE_DISABLED = 'KIOSK_DEVICE_DISABLED',
KIOSK_SESSION_STARTED = 'KIOSK_SESSION_STARTED',
KIOSK_SESSION_ENDED = 'KIOSK_SESSION_ENDED',

// M10.21: Kiosk Timeclock Events
KIOSK_CLOCK_IN = 'KIOSK_CLOCK_IN',
KIOSK_CLOCK_OUT = 'KIOSK_CLOCK_OUT',
KIOSK_BREAK_START = 'KIOSK_BREAK_START',
KIOSK_BREAK_END = 'KIOSK_BREAK_END',
KIOSK_PIN_RATE_LIMITED = 'KIOSK_PIN_RATE_LIMITED',
KIOSK_GEOFENCE_BLOCKED = 'KIOSK_GEOFENCE_BLOCKED',
```

---

## Service Architecture

### kiosk-device.service.ts
- `createDevice(orgId, branchId, name, createdById)` → returns { device, plaintextSecret }
- `rotateSecret(deviceId)` → returns { device, plaintextSecret }
- `validateDeviceSecret(publicId, plaintextSecret)` → returns device or null
- `updateDevice(deviceId, updates)`
- `deleteDevice(deviceId)`
- `listDevices(orgId, branchId?)`
- `getDevice(deviceId)`

### kiosk-session.service.ts
- `startSession(deviceId, ipAddress, userAgent)` → sessionId
- `validateSession(sessionId)` → device + session or null
- `heartbeat(sessionId)`
- `endSession(sessionId, reason)`
- `cleanupExpiredSessions()`

### kiosk-timeclock.service.ts
- `lookupUserByPin(orgId, pin)` → user (H1: org-scoped query)
- `checkPinRateLimit(orgId, kioskDeviceId)` → allowed or throw (H3: no timers)
- `clockIn(sessionId, pin, geoMetadata?)` → timeEntry
- `clockOut(sessionId, pin, geoMetadata?)` → timeEntry
- `startBreak(sessionId, pin)` → breakEntry
- `endBreak(sessionId, pin)` → breakEntry
- `getStatus(sessionId, pin)` → clock status

### kiosk-reporting.service.ts
- `getKpis(orgId, branchId?, startDate?, endDate?)` → KPIs
- `exportEvents(orgId, branchId?, startDate?, endDate?)` → CSV with hash

---

## Kimai Parity Reference

Kimai doesn't have a kiosk mode—this is a ChefCloud-specific enhancement for restaurant operations. However, we follow these Kimai-inspired patterns:

| Kimai Pattern | ChefCloud M10.21 Adaptation |
|---------------|----------------------------|
| API tokens | Device secret (Argon2id hashed) |
| Activity linking | Branch binding from device |
| Timeclock model | Reuse WorkforceTimeclockService |
| Audit trail | WorkforceAuditService integration |

---

## Security Considerations

1. **Device Secret Storage**: Argon2id with same params as user passwords
2. **PIN Lookup**: Query MUST be org-scoped to prevent cross-org user leaks (H1)
3. **Rate Limiting**: DB-based sliding window count, NO setInterval (H3)
4. **Branch Spoofing**: Never accept branchId from kiosk client—derive from device (H7)
5. **Session Management**: Short-lived sessions with heartbeat, auto-expire on rotation
6. **IP Validation**: Optional CIDR allowlist for enterprise deployments

---

## Testing Strategy

### E2E Tests (`workforce-m1021-kiosk.e2e-spec.ts`)

| Test Case | Description |
|-----------|-------------|
| A1 | L4+ can create kiosk device |
| A2 | Device secret is returned one-time only |
| A3 | L2/L3 cannot create kiosk device |
| A4 | Device belongs to correct org/branch |
| B1 | Device can authenticate with valid secret |
| B2 | Invalid secret rejected |
| B3 | Session heartbeat extends timeout |
| C1 | Valid PIN clocks in user |
| C2 | Invalid PIN rejected |
| C3 | PIN rate limiting enforced (H3) |
| C4 | Cross-org PIN lookup prevented (H1) |
| D1 | Geofence enforcement integrated |
| D2 | requireKioskForTimeclock blocks normal API |
| E1 | KPIs calculated correctly |
| E2 | CSV export includes hash trailer |

---

## File Structure

```
services/api/src/workforce/
├── kiosk-device.service.ts       # Device CRUD + secret management
├── kiosk-session.service.ts      # Session lifecycle
├── kiosk-timeclock.service.ts    # PIN auth + clock operations
├── kiosk-reporting.service.ts    # KPIs + exports
├── kiosk-device.controller.ts    # Admin endpoints (L4+)
├── public-kiosk.controller.ts    # Public endpoints (device-auth)

apps/web/src/pages/workforce/
├── kiosk-devices.tsx             # Admin device management page
├── kiosk/
│   └── [publicId].tsx            # Fullscreen kiosk page

services/api/test/e2e/
├── workforce-m1021-kiosk.e2e-spec.ts
```

---

## Implementation Checklist

- [ ] Add Prisma models (KioskDevice, KioskDeviceSession, KioskPinAttempt, KioskClockEvent)
- [ ] Add WorkforcePolicy fields (requireKioskForTimeclock, etc.)
- [ ] Add audit actions to WorkforceAuditAction enum
- [ ] Implement kiosk-device.service.ts
- [ ] Implement kiosk-session.service.ts
- [ ] Implement kiosk-timeclock.service.ts
- [ ] Implement kiosk-reporting.service.ts
- [ ] Implement kiosk-device.controller.ts
- [ ] Implement public-kiosk.controller.ts
- [ ] Update workforce.module.ts with new services/controllers
- [ ] Create admin UI page (kiosk-devices.tsx)
- [ ] Create kiosk UI page ([publicId].tsx)
- [ ] Write E2E tests
- [ ] Run verification gates
- [ ] Commit and push
