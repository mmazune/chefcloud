# M11.6 Hypotheses — Supplier Catalog + Reorder Automation

## Pre-Implementation Risk Analysis

| ID | Hypothesis | Confidence | Failure Mode | Mitigation | Test Coverage |
|----|-----------|------------|--------------|------------|---------------|
| H1 | SupplierItem vendorSku uniqueness will leak across orgs if constraint only on (vendorId, vendorSku) | 90% | Org1 vendor's SKU "ABC" conflicts with Org2 same vendor ID (impossible with proper FK, but still need org scoping) | `@@unique([orgId, vendorId, vendorSku])` includes orgId | E2E: Create same vendorSku for different orgs - must succeed |
| H2 | UOM conversion factor misapplied will cause wrong vendor qty calculation | 85% | Factor of 12 (case to unit) applied inversely: 12 units → 144 cases instead of 1 case | Explicit formula: `suggestedVendorQty = ceil(suggestedBaseQty / factor)` with unit tests | E2E: Verify factor math with known values |
| H3 | Suggestion run idempotency will fail without hash causing duplicate runs | 90% | User clicks "Generate" twice rapidly → 2 runs with same suggestions | `deterministicHash` computed from sorted item IDs + on-hand + reorder points; unique constraint returns existing | E2E: Create run twice with same inputs → same runId |
| H4 | Draft PO generation will create duplicates without idempotency key | 88% | `generate-pos` called twice → 2 POs per vendor | Use `idempotencyKey = "reorder:<runId>:<vendorId>"` on PurchaseOrderV2 | E2E: Call generate-pos twice → same PO IDs |
| H5 | Price history with overlapping effectiveTo will cause ambiguous latest price selection | 80% | Two prices both have `effectiveTo = null` for same supplier item | Close previous price (`effectiveTo = new.effectiveFrom - 1day`) when adding new; query uses `ORDER BY effectiveFrom DESC LIMIT 1` | E2E: Add 2 prices → verify latest is selected |
| H6 | Export hash will mismatch on Windows due to CRLF vs LF | 95% | Hash computed with CRLF doesn't match client-side LF hash | Normalize to LF before hashing, add BOM after hash | E2E: Verify X-Nimbus-Export-Hash header matches computed |
| H7 | RBAC will incorrectly allow L2 to generate POs | 85% | Staff user calls generate-pos → unauthorized POs created | Explicit `@Roles('L4')` decorator on generate-pos endpoint | E2E: L2 token → 403 on generate-pos |
| H8 | Receipt-derived price inference will duplicate entries on re-post | 90% | Idempotent receipt post adds SupplierPrice each time | `@@unique([supplierItemId, sourceReceiptLineId])` with upsert logic | E2E: Post receipt twice → one SupplierPrice entry |
| H9 | ReorderPolicy override will not take precedence over item reorderLevel | 80% | Engine uses item.reorderLevel instead of policy.reorderPointBaseQty | Service checks ReorderPolicy first, falls back to item | E2E: Policy 100 vs item 10 → suggestion uses 100 |
| H10 | Deterministic hash will vary if item order changes | 85% | Hash(a,b) ≠ Hash(b,a) → false negatives on idempotency | Sort inputs by inventoryItemId before hashing | Unit test: Verify hash stability |

## Verification Plan

After implementation, each hypothesis will be marked:
- ✅ **CONFIRMED**: Risk mitigated as designed
- ❌ **FAILED**: Risk materialized, required fix
- ⚠️ **PARTIAL**: Partial mitigation, documented limitation
