# M11.3 Hypotheses - Inventory Transfers + Waste Ops

## H1: Idempotent Receive/Post Race Condition

**Hypothesis:** If two concurrent `POST /transfers/:id/receive` requests arrive for the same transfer, both could check `status === 'IN_TRANSIT'` before either updates to `RECEIVED`, resulting in duplicate ledger entries.

**Test:** Use `Promise.all` to fire 5 concurrent receive requests on the same transfer. Assert exactly one set of ledger entries exists.

**Mitigation:** Use Prisma `$transaction` with `UPDATE ... WHERE status = 'IN_TRANSIT'` returning affected rows. If 0 rows affected, treat as idempotent return. Alternatively, use database-level advisory locks or optimistic locking with version field.

---

## H2: Negative Stock Race on Transfer Ship

**Hypothesis:** Two transfers from the same source location could both pass the on-hand check if executed concurrently, resulting in negative stock.

**Test:** Create two transfers for the same item from the same location where total qty > on-hand. Fire concurrent ship requests. Assert one succeeds, one fails with `BadRequestException`.

**Mitigation:** Calculate on-hand within the same transaction that creates ledger entries. Use `SELECT ... FOR UPDATE` on relevant ledger entries or aggregate within transaction.

---

## H3: UOM Rounding Accumulation

**Hypothesis:** If transfers use input UOM with fractional conversion factors, accumulated rounding errors could cause ledger discrepancies over many transfers.

**Test:** Create 100 transfers of 1.333... base units each. Verify total received matches total shipped within acceptable tolerance (4 decimal places).

**Mitigation:** Store all quantities in base UOM with Decimal(12,4) precision. Perform conversion at input boundary only. Document acceptable tolerance in business rules.

---

## H4: Void-After-Ship Attempt

**Hypothesis:** User might attempt to void a transfer that's already IN_TRANSIT, expecting to cancel the stock movement.

**Test:** Ship a transfer, then call `POST /transfers/:id/void`. Assert 400 response with clear message.

**Mitigation:** State machine strictly enforces VOID only from DRAFT. If business requires void from IN_TRANSIT, add separate "reversal" workflow that creates offsetting ledger entries (future enhancement).

---

## H5: Cross-Branch Scoping Leak

**Hypothesis:** A user from Branch A could create a transfer sourcing from Branch B's locations if API doesn't validate fromBranchId matches user's branch or org-wide access.

**Test:** Attempt to create transfer with fromBranchId different from user's branch context. Assert 403 or validation error.

**Mitigation:** Service layer validates fromBranchId and toBranchId are both within the org. For L3 users, fromBranchId must match their assigned branch. L4+ can do cross-branch within org.

---

## H6: Export Hash Determinism

**Hypothesis:** If CSV export ordering is not deterministic (e.g., database returns records in arbitrary order), the X-Nimbus-Export-Hash will differ between calls even if data hasn't changed.

**Test:** Call export endpoint twice in succession. Assert identical hash values.

**Mitigation:** Always use explicit `ORDER BY` clause on a stable field (e.g., `createdAt DESC, id ASC`). Include all tie-breaker fields.

---

## H7: Waste Double-Post via Browser Retry

**Hypothesis:** User clicks "Post" button, network timeout occurs, browser retries the request. Without idempotency, ledger entries could be duplicated.

**Test:** Post a waste document. Immediately call post again. Assert second call returns `{ isAlreadyPosted: true }` with no new ledger entries.

**Mitigation:** Status-based idempotency: if `status === 'POSTED'`, return early with flag. Transaction ensures atomic status update + ledger creation.

---

## H8: E2E Test Hang on Unclosed Handles

**Hypothesis:** If E2E tests don't properly close database connections or NestJS app, Jest will hang waiting for handles to close.

**Test:** Run full E2E suite with `--detectOpenHandles`. Assert clean exit without `--forceExit`.

**Mitigation:** 
- Ensure `afterAll` calls `app.close()` 
- Use shared `cleanup()` helper that handles edge cases
- Don't create subscriptions or intervals without cleanup
- Verify PrismaService.$disconnect is called

---

## H9: Partial Receive Variance

**Hypothesis:** When receiving a transfer, actual received qty might differ from shipped qty (damage in transit). System must track this variance without blocking receive.

**Test:** Ship 100 units, receive 95 units. Assert transfer.status becomes RECEIVED, ledger shows correct amounts, and variance is calculable from lines.

**Mitigation:** Allow `qtyReceived` to differ from `qtyShipped`. Ledger entry uses `qtyReceived`. Add optional variance report/alert (future enhancement).

---

## H10: Waste Post with Zero Quantity Line

**Hypothesis:** A waste document with a line where qty=0 could create misleading ledger entries or division-by-zero errors in cost calculations.

**Test:** Create waste with one line qty=10, one line qty=0. Post. Assert only non-zero line creates ledger entry.

**Mitigation:** Validate `qty > 0` on each line during POST creation. Reject lines with zero or negative quantities.

---

## Validation Checkpoints

Before implementation, verify:
- [ ] H1-H2: Race condition handling strategy chosen
- [ ] H3: Decimal precision strategy documented
- [ ] H4: State machine transitions clearly defined
- [ ] H5: Branch scoping rules in DTOs
- [ ] H6: Export ORDER BY includes tie-breakers
- [ ] H7: Idempotency pattern matches receipts.service.ts
- [ ] H8: E2E cleanup pattern matches existing tests
- [ ] H9: Variance tracking requirement confirmed
- [ ] H10: Line quantity validation in place
