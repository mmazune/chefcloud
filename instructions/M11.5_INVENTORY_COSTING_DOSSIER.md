# M11.5 Inventory Costing + Valuation + COGS — Feature Dossier

## 1. Overview

**Milestone:** M11.5 Inventory Costing + Valuation + COGS  
**Sprint:** M11 Inventory Essentials  
**Status:** Implementation  
**Commit Base:** 6359836 (M11.4 complete)

### Objective
Make inventory financially meaningful by:
1. Recording item costs from Goods Receipts (M11.2)
2. Computing on-hand valuation by (branch/location/item)
3. Computing depletion COGS from M11.4 recipe depletion postings
4. Providing minimal operational UI for valuation + cost review
5. Providing exports with BOM + stable ordering + X-Nimbus-Export-Hash

---

## 2. Feature Parity Analysis

### 2.1 InvenTree Cost Patterns (MIT, ADAPT)

| InvenTree Feature | M11.5 Implementation | Status |
|-------------------|---------------------|--------|
| StockItem.purchase_price | GoodsReceiptLineV2.unitCost → InventoryCostLayer | ✓ |
| StockItem weighted tracking | InventoryCostLayer with WAC method | ✓ |
| Stock value calculation | getValuation() computed from ledger + costLayer | ✓ |
| Audit trail for costs | Append-only InventoryCostLayer, no UPDATE/DELETE | ✓ |
| COGS on consumption | DepletionCostBreakdown on OrderInventoryDepletion | ✓ |

### 2.2 Key Differences from InvenTree

| Aspect | InvenTree | NimbusPOS M11.5 |
|--------|-----------|-----------------|
| Stock Model | Mutable StockItem.quantity | Append-only InventoryLedgerEntry |
| Cost Storage | purchase_price per StockItem | InventoryCostLayer per receipt posting |
| WAC Calculation | Computed from StockItems | Incremental WAC on receive, stored per layer |
| Cost Method | FIFO, LIFO, WAC selectable | WAC only for v1 |
| Valuation Query | Stock value endpoint | GET /inventory/valuation/on-hand |
| COGS Tracking | Consumption entries only | DepletionCostBreakdown with lineCogs |

---

## 3. Data Models

### 3.1 InventoryCostLayer (Append-Only Cost History)

```prisma
model InventoryCostLayer {
  id           String   @id @default(cuid())
  orgId        String
  branchId     String
  itemId       String
  locationId   String?               // Optional: for location-level costing
  method       CostMethod @default(WAC)
  qtyReceived  Decimal  @db.Decimal(12, 4)  // Qty added in this layer
  unitCost     Decimal  @db.Decimal(12, 4)  // Cost per unit in base UOM
  priorWac     Decimal  @db.Decimal(12, 4)  // WAC before this layer
  newWac       Decimal  @db.Decimal(12, 4)  // WAC after this layer
  sourceType   CostSourceType        // GOODS_RECEIPT, MANUAL_ADJUSTMENT, INITIAL_SEED
  sourceId     String                // Receipt line ID, adjustment ID, etc.
  effectiveAt  DateTime @default(now())
  createdById  String
  metadata     Json?
  createdAt    DateTime @default(now())

  org      Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch   Branch         @relation(fields: [branchId], references: [id], onDelete: Cascade)
  item     InventoryItem  @relation(fields: [itemId], references: [id], onDelete: Restrict)
  location InventoryLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull)
  createdBy User          @relation(fields: [createdById], references: [id], onDelete: Restrict)

  @@index([orgId, branchId, itemId])
  @@index([itemId, effectiveAt])
  @@index([sourceType, sourceId])
  @@map("inventory_cost_layers")
}

enum CostMethod {
  WAC  // Weighted Average Cost
  // FIFO and LIFO reserved for future
}

enum CostSourceType {
  GOODS_RECEIPT
  MANUAL_ADJUSTMENT
  INITIAL_SEED
}
```

### 3.2 DepletionCostBreakdown (COGS per Depletion)

```prisma
model DepletionCostBreakdown {
  id           String   @id @default(cuid())
  orgId        String
  depletionId  String
  orderId      String
  itemId       String
  qtyDepleted  Decimal  @db.Decimal(12, 4)  // Quantity consumed (positive)
  unitCost     Decimal  @db.Decimal(12, 4)  // WAC at time of depletion
  lineCogs     Decimal  @db.Decimal(12, 4)  // qtyDepleted × unitCost
  computedAt   DateTime @default(now())
  metadata     Json?
  createdAt    DateTime @default(now())

  depletion OrderInventoryDepletion @relation(fields: [depletionId], references: [id], onDelete: Cascade)
  item      InventoryItem @relation(fields: [itemId], references: [id], onDelete: Restrict)

  @@unique([depletionId, itemId])
  @@index([orgId, orderId])
  @@index([itemId])
  @@map("depletion_cost_breakdowns")
}
```

---

## 4. WAC Calculation Rules

### 4.1 WAC Formula

When receiving stock:
```
newWac = (existingQty × existingWac + receivedQty × receivedUnitCost) / (existingQty + receivedQty)
```

### 4.2 Scoping Decision
- **Branch-level WAC per item** (orgId + branchId + itemId)
- Different branches may have different costs (local suppliers, etc.)
- Location-level optional for future granularity

### 4.3 Precision Rules
- Store all costs with Decimal(12, 4) - no rounding until final report/export
- Round only at reporting/export boundary (2 decimal places for display)
- WAC updates are atomic within transaction

### 4.4 Edge Cases
| Scenario | Behavior |
|----------|----------|
| First receipt (no prior WAC) | WAC = receivedUnitCost |
| Zero on-hand, new receipt | WAC = receivedUnitCost |
| Negative on-hand (allowed) | Skip WAC update, preserve existing |
| Zero qty received | Error - invalid operation |

---

## 5. Integration Points

### 5.1 Goods Receipt Posting (M11.2)

When `ReceiptsService.post()` posts a receipt:
1. Existing: Create ledger entries (reason=RECEIVE)
2. **NEW:** For each line, call `CostingService.appendCostLayer()`:
   - Get current on-hand qty for (branchId, itemId)
   - Get current WAC for (branchId, itemId)
   - Compute newWac using formula
   - Create InventoryCostLayer with priorWac, newWac, sourceType=GOODS_RECEIPT

### 5.2 Depletion Posting (M11.4)

When `InventoryDepletionService.depleteForOrder()` posts:
1. Existing: Create SALE ledger entries
2. **NEW:** For each depleted item, call `CogsService.recordBreakdown()`:
   - Get current WAC for (branchId, itemId)
   - Create DepletionCostBreakdown with unitCost=currentWac
   - lineCogs = qtyDepleted × unitCost

### 5.3 Valuation Query

`GET /inventory/valuation/on-hand`:
- Sum ledger entries by (branchId, locationId?, itemId) → onHandQty
- Get current WAC for each item
- extendedValue = onHandQty × unitCost
- Return with hash for integrity

---

## 6. API Endpoints

### 6.1 Valuation Endpoints (RBAC: L4+)

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /inventory/valuation/on-hand | On-hand valuation with optional filters |
| GET | /inventory/valuation/summary | Branch/location summary totals |
| GET | /inventory/export/valuation | CSV export with BOM + hash |

### 6.2 COGS Endpoints (RBAC: L4+)

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /inventory/cogs | COGS by date range, branch, item |
| GET | /inventory/cogs/by-order | COGS breakdown per order |
| GET | /inventory/export/cogs | CSV export with BOM + hash |

### 6.3 Cost Layer Endpoints (RBAC: L4+)

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /inventory/cost-layers | List cost layers with filters |
| GET | /inventory/cost-layers/:itemId | Cost history for specific item |

---

## 7. Web UI Pages

### 7.1 /inventory/valuation
- Filters: branch, location, item search
- Table: SKU, Name, On-Hand Qty, Unit Cost, Extended Value
- Summary: Total Value, Item Count
- Export CSV button

### 7.2 /inventory/cogs
- Filters: date range, branch
- Table: Date, Order #, Item, Qty, Unit Cost, Line COGS
- Summary: Total COGS, Orders Count
- Export CSV button

---

## 8. Audit Actions

- COST_LAYER_APPENDED - When cost layer created from receipt
- COST_LAYER_MANUAL - When manual adjustment creates layer
- COGS_COMPUTED - When depletion COGS breakdown created
- VALUATION_EXPORTED - When valuation CSV exported
- COGS_EXPORTED - When COGS CSV exported

---

## 9. Exports

### 9.1 Valuation Export
```csv
SKU,Name,Branch,Location,On-Hand Qty,Unit Cost,Extended Value,As Of
```

### 9.2 COGS Export
```csv
Order ID,Order Number,Order Date,Item SKU,Item Name,Qty Depleted,Unit Cost,Line COGS
```

Both exports include:
- UTF-8 BOM (0xFEFF)
- Stable ordering by createdAt ASC, id ASC
- X-Nimbus-Export-Hash header (SHA-256)

---

## 10. Implementation Order

1. Prisma models + migration
2. InventoryCostingService (WAC + cost layers)
3. InventoryValuationService (on-hand valuation)
4. InventoryCogsService (depletion COGS)
5. Extend receipts.service.ts with cost layer hook
6. Extend inventory-depletion.service.ts with COGS hook
7. Create valuation/cogs controllers
8. Extend export service
9. Web UI pages
10. E2E tests

---

## 11. Non-Goals for M11.5

- FIFO/LIFO costing methods (future)
- Standard costing
- Cost variance tracking
- Multi-currency costing
- Location-level WAC (branch-level only)
- Periodic valuation snapshots (real-time only)
