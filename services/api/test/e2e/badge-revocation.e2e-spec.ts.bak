import { createE2EApp } from '../helpers/e2e-bootstrap';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../../src/app.module';
import { PrismaService } from '../../src/prisma.service';
import { JwtService } from '@nestjs/jwt';
import { withTimeout } from '../helpers/with-timeout';

describe('Badge Revocation & Session Invalidation (E25) - E2E', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let jwtService: JwtService;

  let testOrg: any;
  let testBranch: any;
  let testUser: any;
  let testBadge: any;
  let adminToken: string;

  beforeAll(async () => {
    app = await createE2EApp({ imports: [AppModule] });

    prisma = app.get<PrismaService>(PrismaService);
    jwtService = app.get<JwtService>(JwtService);

    await withTimeout(setupTestData(), {
      label: 'badge-revocation setupTestData',
      ms: 30000,
    });
  });

  afterAll(async () => {
    await cleanupTestData();
    await app.close();
  });

  async function setupTestData() {
    // Create test organization
    testOrg = await prisma.client.org.create({
      data: {
        slug: 'badge-revoke-test-org',
        name: 'Badge Revocation Test Org',
      },
    });

    // Create test branch
    testBranch = await prisma.client.branch.create({
      data: {
        orgId: testOrg.id,
        name: 'Test Branch',
        slug: 'test-branch-badge',
        timezone: 'Africa/Kampala',
      },
    });

    // Create test user
    testUser = await prisma.client.user.create({
      data: {
        orgId: testOrg.id,
        branchId: testBranch.id,
        email: 'badge-test-user@test.local',
        firstName: 'Badge',
        lastName: 'Tester',
        roleLevel: 'L3',
        passwordHash: '$2a$10$dummyHashForTesting', // Not used for MSR login
        sessionVersion: 0, // E25: Initial version
      },
    });

    // Create employee profile with badge
    const badgeCode = 'TESTBADGE001';
    const _employeeProfile = await prisma.client.employeeProfile.create({
      data: {
        userId: testUser.id,
        employeeCode: 'EMP-TEST-001',
        badgeId: badgeCode,
      },
    });

    // Create badge asset
    testBadge = await prisma.client.badgeAsset.create({
      data: {
        orgId: testOrg.id,
        code: badgeCode,
        state: 'ACTIVE',
        assignedUserId: testUser.id,
      },
    });

    // Create admin user for badge management
    const adminUser = await prisma.client.user.create({
      data: {
        orgId: testOrg.id,
        branchId: testBranch.id,
        email: 'admin@test.local',
        firstName: 'Admin',
        lastName: 'User',
        roleLevel: 'L5',
        passwordHash: 'dummy',
      },
    });

    // Generate admin token
    adminToken = jwtService.sign({
      sub: adminUser.id,
      email: adminUser.email,
      orgId: testOrg.id,
      roleLevel: 'L5',
      sv: 0,
    });
  }

  async function cleanupTestData() {
    // Delete in dependency order
    await prisma.client.employeeProfile.deleteMany({
      where: { userId: testUser.id },
    });
    await prisma.client.badgeAsset.deleteMany({
      where: { orgId: testOrg.id },
    });
    await prisma.client.user.deleteMany({
      where: { orgId: testOrg.id },
    });
    await prisma.client.branch.deleteMany({
      where: { orgId: testOrg.id },
    });
    await prisma.client.org.deleteMany({
      where: { id: testOrg.id },
    });
  }

  describe('Badge Revocation Flow', () => {
    it('should authenticate via badge swipe and include badgeId in token', async () => {
      const response = await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(201);

      expect(response.body).toHaveProperty('access_token');
      expect(response.body.user.id).toBe(testUser.id);

      // Decode token to check claims
      const decoded = jwtService.decode(response.body.access_token) as any;
      expect(decoded.sv).toBe(0); // Initial session version
      expect(decoded.badgeId).toBe(testBadge.code);
      expect(decoded.jti).toBeDefined(); // JWT ID for deny list
    });

    it('should access protected endpoint with valid token', async () => {
      // Login via badge
      const loginRes = await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(201);

      const token = loginRes.body.access_token;

      // Access protected endpoint
      const profileRes = await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      expect(profileRes.body.id).toBe(testUser.id);
    });

    it('should reject login with REVOKED badge', async () => {
      // Revoke badge
      await request(app.getHttpServer())
        .post(`/badges/${testBadge.code}/revoke`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({ reason: 'Security concern' })
        .expect(200);

      // Attempt login with revoked badge
      await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(401);

      // Reset badge state for next tests
      await prisma.client.badgeAsset.update({
        where: { code: testBadge.code },
        data: { state: 'ACTIVE', assignedUserId: testUser.id },
      });
    });

    it('should invalidate existing token when badge is revoked (< 2s)', async () => {
      // Login and get token
      const loginRes = await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(201);

      const token = loginRes.body.access_token;

      // Verify token works
      await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      // Get current session version
      const userBefore = await prisma.client.user.findUnique({
        where: { id: testUser.id },
        select: { sessionVersion: true },
      });

      // Revoke badge
      const revokeStart = Date.now();
      await request(app.getHttpServer())
        .post(`/badges/${testBadge.code}/revoke`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({ reason: 'Lost' })
        .expect(200);

      // Check session version was incremented
      const userAfter = await prisma.client.user.findUnique({
        where: { id: testUser.id },
        select: { sessionVersion: true },
      });
      expect(userAfter!.sessionVersion).toBe(userBefore!.sessionVersion + 1);

      // Token should now be rejected (within 2 seconds)
      const invalidationTime = Date.now() - revokeStart;
      
      const response = await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(401);

      expect(response.body.message).toContain('invalidated');
      expect(invalidationTime).toBeLessThan(2000); // E25 requirement: < 2s

      // Reset badge for next tests
      await prisma.client.badgeAsset.update({
        where: { code: testBadge.code },
        data: { state: 'ACTIVE', assignedUserId: testUser.id },
      });
      await prisma.client.user.update({
        where: { id: testUser.id },
        data: { sessionVersion: 0 },
      });
    });

    it('should allow new login after badge revocation with updated version', async () => {
      // Login
      const loginRes1 = await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(201);

      const token1 = loginRes1.body.access_token;
      const decoded1 = jwtService.decode(token1) as any;
      expect(decoded1.sv).toBe(0);

      // Revoke badge
      await request(app.getHttpServer())
        .post(`/badges/${testBadge.code}/revoke`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({ reason: 'Security' })
        .expect(200);

      // Old token should fail
      await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token1}`)
        .expect(401);

      // Restore badge to ACTIVE for new login
      await prisma.client.badgeAsset.update({
        where: { code: testBadge.code },
        data: { state: 'ACTIVE', assignedUserId: testUser.id },
      });

      // New login should work with updated session version
      const loginRes2 = await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(201);

      const token2 = loginRes2.body.access_token;
      const decoded2 = jwtService.decode(token2) as any;
      expect(decoded2.sv).toBe(1); // Incremented version

      // New token should work
      await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token2}`)
        .expect(200);

      // Reset for next tests
      await prisma.client.user.update({
        where: { id: testUser.id },
        data: { sessionVersion: 0 },
      });
    });

    it('should invalidate sessions when badge is reported LOST', async () => {
      // Login
      const loginRes = await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(201);

      const token = loginRes.body.access_token;

      // Report lost
      await request(app.getHttpServer())
        .post(`/badges/${testBadge.code}/lost`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      // Token should be invalidated
      await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(401);

      // Reset
      await prisma.client.badgeAsset.update({
        where: { code: testBadge.code },
        data: { state: 'ACTIVE', assignedUserId: testUser.id },
      });
      await prisma.client.user.update({
        where: { id: testUser.id },
        data: { sessionVersion: 0 },
      });
    });

    it('should NOT reinstate old tokens when badge is RETURNED', async () => {
      // Login
      const loginRes = await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(201);

      const token = loginRes.body.access_token;

      // Revoke
      await request(app.getHttpServer())
        .post(`/badges/${testBadge.code}/revoke`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({ reason: 'Test' })
        .expect(200);

      // Mark as RETURNED
      await prisma.client.badgeAsset.update({
        where: { code: testBadge.code },
        data: { state: 'RETURNED', assignedUserId: null },
      });

      // Old token should STILL be invalid
      await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(401);

      // But new login should work
      await prisma.client.badgeAsset.update({
        where: { code: testBadge.code },
        data: { state: 'ACTIVE', assignedUserId: testUser.id },
      });

      const newLoginRes = await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(201);

      await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${newLoginRes.body.access_token}`)
        .expect(200);

      // Cleanup
      await prisma.client.user.update({
        where: { id: testUser.id },
        data: { sessionVersion: 0 },
      });
    });
  });

  describe('Session Version Validation', () => {
    it('should reject token with mismatched session version', async () => {
      // Create token with version 0
      const token = jwtService.sign({
        sub: testUser.id,
        email: testUser.email,
        orgId: testOrg.id,
        roleLevel: 'L3',
        sv: 0,
        jti: 'test-jti-123',
      });

      // Token should work initially
      await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      // Manually increment session version (simulating revocation)
      await prisma.client.user.update({
        where: { id: testUser.id },
        data: { sessionVersion: 1 },
      });

      // Token should now be rejected
      const response = await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(401);

      expect(response.body.message).toContain('invalidated');

      // Reset
      await prisma.client.user.update({
        where: { id: testUser.id },
        data: { sessionVersion: 0 },
      });
    });
  });

  describe('Performance & Timing', () => {
    it('should invalidate session within 2 seconds (E25 requirement)', async () => {
      const loginRes = await request(app.getHttpServer())
        .post('/auth/msr')
        .send({
          trackData: `CLOUDBADGE:${testBadge.code}`,
          branchId: testBranch.id,
        })
        .expect(201);

      const token = loginRes.body.access_token;

      const startTime = Date.now();
      
      // Revoke badge
      await request(app.getHttpServer())
        .post(`/badges/${testBadge.code}/revoke`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({ reason: 'Perf test' });

      // Verify invalidation
      await request(app.getHttpServer())
        .get('/workforce/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(401);

      const elapsedTime = Date.now() - startTime;
      
      // E25 Acceptance Criteria: â‰¤ 2 seconds
      expect(elapsedTime).toBeLessThan(2000);

      // Cleanup
      await prisma.client.badgeAsset.update({
        where: { code: testBadge.code },
        data: { state: 'ACTIVE', assignedUserId: testUser.id },
      });
      await prisma.client.user.update({
        where: { id: testUser.id },
        data: { sessionVersion: 0 },
      });
    });
  });
});
