#!/usr/bin/env node
/**
 * E2E Test Profiler - Parses Jest JSON output and provides performance insights
 * 
 * Usage:
 *   pnpm test:e2e:profile
 * 
 * Outputs:
 *   - Top 20 slowest individual tests
 *   - Top 20 slowest test files
 *   - Total duration
 *   - Open handles warning (if detected)
 * 
 * Input: .e2e-results.json (generated by Jest --json)
 * Output: Console summary + optional .e2e-profile.txt artifact
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  green: '\x1b[32m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m',
};

/**
 * Format duration in seconds to human-readable format
 */
function formatDuration(ms) {
  if (ms < 1000) return `${ms}ms`;
  const seconds = (ms / 1000).toFixed(2);
  if (ms < 60000) return `${seconds}s`;
  const minutes = Math.floor(ms / 60000);
  const remainingSeconds = ((ms % 60000) / 1000).toFixed(0);
  return `${minutes}m ${remainingSeconds}s`;
}

/**
 * Parse Jest JSON results and extract performance data
 */
function parseResults(resultsPath) {
  if (!fs.existsSync(resultsPath)) {
    console.error(`${colors.red}Error: Results file not found at ${resultsPath}${colors.reset}`);
    console.error('Make sure to run: pnpm test:e2e:profile');
    process.exit(1);
  }

  const rawData = fs.readFileSync(resultsPath, 'utf-8');
  let results;
  
  try {
    results = JSON.parse(rawData);
  } catch (err) {
    console.error(`${colors.red}Error: Failed to parse JSON results${colors.reset}`);
    console.error(err.message);
    process.exit(1);
  }

  return results;
}

/**
 * Extract individual test timings from test results
 */
function extractTestTimings(results) {
  const tests = [];

  for (const testResult of results.testResults || []) {
    const filePath = testResult.name || testResult.testFilePath || 'unknown';
    const fileName = path.basename(filePath);

    for (const assertionResult of testResult.assertionResults || []) {
      tests.push({
        file: fileName,
        fullPath: filePath,
        suite: assertionResult.ancestorTitles.join(' > '),
        test: assertionResult.title,
        duration: assertionResult.duration || 0,
        status: assertionResult.status,
      });
    }
  }

  return tests;
}

/**
 * Aggregate test timings by file
 */
function aggregateByFile(results) {
  const fileStats = new Map();

  for (const testResult of results.testResults || []) {
    const filePath = testResult.name || testResult.testFilePath || 'unknown';
    const fileName = path.basename(filePath);
    const duration = testResult.perfStats?.runtime || (testResult.endTime - testResult.startTime);
    
    // Count tests by status
    const assertions = testResult.assertionResults || [];
    const passed = assertions.filter(a => a.status === 'passed').length;
    const failed = assertions.filter(a => a.status === 'failed').length;
    const pending = assertions.filter(a => a.status === 'pending' || a.status === 'skipped').length;
    const numTests = assertions.length;

    if (!fileStats.has(fileName)) {
      fileStats.set(fileName, {
        file: fileName,
        fullPath: filePath,
        duration: duration,
        numTests: numTests,
        passed: passed,
        failed: failed,
        pending: pending,
      });
    }
  }

  return Array.from(fileStats.values());
}

/**
 * Print top slowest tests
 */
function printSlowTests(tests, limit = 20) {
  const sorted = tests
    .filter(t => t.status !== 'pending')
    .sort((a, b) => b.duration - a.duration)
    .slice(0, limit);

  console.log(`\n${colors.bright}${colors.cyan}━━━ TOP ${limit} SLOWEST INDIVIDUAL TESTS ━━━${colors.reset}\n`);
  console.log(`${colors.gray}Threshold: ${colors.yellow}> 1000ms${colors.reset} ${colors.gray}= slow, ${colors.red}> 5000ms${colors.reset} ${colors.gray}= very slow${colors.reset}\n`);

  sorted.forEach((test, index) => {
    const durationStr = formatDuration(test.duration);
    let durationColor = colors.green;
    
    if (test.duration > 5000) durationColor = colors.red;
    else if (test.duration > 1000) durationColor = colors.yellow;

    console.log(
      `${colors.gray}${String(index + 1).padStart(2)}.${colors.reset} ` +
      `${durationColor}${durationStr.padEnd(10)}${colors.reset} ` +
      `${colors.cyan}${test.file.padEnd(40)}${colors.reset} ` +
      `${test.suite ? test.suite + ' > ' : ''}${test.test}`
    );
  });
}

/**
 * Print top slowest test files
 */
function printSlowFiles(fileStats, limit = 20) {
  const sorted = fileStats
    .sort((a, b) => b.duration - a.duration)
    .slice(0, limit);

  console.log(`\n${colors.bright}${colors.cyan}━━━ TOP ${limit} SLOWEST TEST FILES ━━━${colors.reset}\n`);
  console.log(`${colors.gray}Threshold: ${colors.yellow}> 5000ms${colors.reset} ${colors.gray}= slow, ${colors.red}> 10000ms${colors.reset} ${colors.gray}= very slow${colors.reset}\n`);

  sorted.forEach((file, index) => {
    const durationStr = formatDuration(file.duration);
    let durationColor = colors.green;
    
    if (file.duration > 10000) durationColor = colors.red;
    else if (file.duration > 5000) durationColor = colors.yellow;

    const statusStr = file.failed > 0 
      ? `${colors.red}${file.failed} failed${colors.reset}`
      : `${colors.green}${file.passed} passed${colors.reset}`;

    console.log(
      `${colors.gray}${String(index + 1).padStart(2)}.${colors.reset} ` +
      `${durationColor}${durationStr.padEnd(10)}${colors.reset} ` +
      `${colors.cyan}${file.file.padEnd(50)}${colors.reset} ` +
      `${colors.gray}(${file.numTests} tests, ${statusStr}${colors.gray})${colors.reset}`
    );
  });
}

/**
 * Print summary statistics
 */
function printSummary(results) {
  // Calculate total duration from first to last test
  const testResults = results.testResults || [];
  let totalDuration = 0;
  
  if (testResults.length > 0) {
    const startTimes = testResults.map(t => t.startTime).filter(Boolean);
    const endTimes = testResults.map(t => t.endTime).filter(Boolean);
    
    if (startTimes.length > 0 && endTimes.length > 0) {
      const minStart = Math.min(...startTimes);
      const maxEnd = Math.max(...endTimes);
      totalDuration = maxEnd - minStart;
    }
  }
  
  const totalTests = results.numTotalTests || 0;
  const passedTests = results.numPassedTests || 0;
  const failedTests = results.numFailedTests || 0;
  const pendingTests = results.numPendingTests || 0;
  const totalSuites = results.numTotalTestSuites || 0;
  const passedSuites = results.numPassedTestSuites || 0;
  const failedSuites = results.numFailedTestSuites || 0;

  console.log(`\n${colors.bright}${colors.cyan}━━━ SUMMARY ━━━${colors.reset}\n`);
  
  console.log(`${colors.bright}Total Duration:${colors.reset} ${formatDuration(totalDuration)}`);
  console.log(`${colors.bright}Test Suites:${colors.reset} ${passedSuites} passed, ${failedSuites} failed, ${totalSuites} total`);
  console.log(`${colors.bright}Tests:${colors.reset} ${passedTests} passed, ${failedTests} failed, ${pendingTests} pending, ${totalTests} total`);
  
  if (results.success) {
    console.log(`\n${colors.green}${colors.bright}✓ All tests passed${colors.reset}`);
  } else {
    console.log(`\n${colors.red}${colors.bright}✗ Some tests failed${colors.reset}`);
  }
}

/**
 * Detect and warn about open handles
 */
function checkOpenHandles(results) {
  // Calculate actual test execution time
  const testResults = results.testResults || [];
  let totalDuration = 0;
  let sumFileDurations = 0;
  
  if (testResults.length > 0) {
    const startTimes = testResults.map(t => t.startTime).filter(Boolean);
    const endTimes = testResults.map(t => t.endTime).filter(Boolean);
    
    if (startTimes.length > 0 && endTimes.length > 0) {
      const minStart = Math.min(...startTimes);
      const maxEnd = Math.max(...endTimes);
      totalDuration = maxEnd - minStart;
    }
    
    // Sum individual file durations
    sumFileDurations = testResults
      .map(t => t.perfStats?.runtime || (t.endTime - t.startTime))
      .reduce((sum, duration) => sum + duration, 0);
  }
  
  const overhead = totalDuration - sumFileDurations;
  
  if (overhead > 10000) { // More than 10s overhead
    console.log(`\n${colors.yellow}${colors.bright}⚠ WARNING: Detected ${formatDuration(overhead)} of overhead${colors.reset}`);
    console.log(`${colors.yellow}This may indicate open handles (unclosed connections, timers, etc.)${colors.reset}`);
    console.log(`${colors.gray}Run with --detectOpenHandles to investigate:${colors.reset}`);
    console.log(`${colors.gray}  pnpm exec jest --config ./test/jest-e2e.json --runInBand --detectOpenHandles${colors.reset}\n`);
  }
}

/**
 * Generate recommendations based on profiling data
 */
function generateRecommendations(tests, fileStats) {
  console.log(`\n${colors.bright}${colors.cyan}━━━ RECOMMENDATIONS ━━━${colors.reset}\n`);
  
  const verySlowTests = tests.filter(t => t.duration > 5000).length;
  const verySlowFiles = fileStats.filter(f => f.duration > 10000).length;
  
  if (verySlowTests > 0) {
    console.log(`${colors.yellow}• ${verySlowTests} tests are very slow (> 5s). Consider:${colors.reset}`);
    console.log(`  - Breaking down into smaller, focused tests`);
    console.log(`  - Using mocks for external dependencies`);
    console.log(`  - Converting to slice tests with minimal imports`);
  }
  
  if (verySlowFiles > 0) {
    console.log(`${colors.yellow}• ${verySlowFiles} test files are very slow (> 10s). Consider:${colors.reset}`);
    console.log(`  - Reducing beforeAll/afterAll setup time`);
    console.log(`  - Ensuring proper cleanup (Prisma disconnect, Redis close, etc.)`);
    console.log(`  - Using Test.createTestingModule() with minimal imports`);
  }
  
  const failedFiles = fileStats.filter(f => f.failed > 0);
  if (failedFiles.length > 0) {
    console.log(`${colors.red}• ${failedFiles.length} test files have failures. Fix these first before optimizing.${colors.reset}`);
  }
  
  console.log(`\n${colors.gray}For detailed analysis, see: E2E_PERFORMANCE_DIAGNOSTIC_REPORT.md${colors.reset}`);
}

/**
 * Main entry point
 */
function main() {
  const resultsPath = path.join(__dirname, '..', '.e2e-results.json');
  
  console.log(`${colors.bright}${colors.cyan}╔══════════════════════════════════════════════════════════════╗${colors.reset}`);
  console.log(`${colors.bright}${colors.cyan}║           E2E Test Performance Profiler v1.0                 ║${colors.reset}`);
  console.log(`${colors.bright}${colors.cyan}╚══════════════════════════════════════════════════════════════╝${colors.reset}`);
  
  console.log(`\n${colors.gray}Analyzing results from: ${resultsPath}${colors.reset}`);
  
  const results = parseResults(resultsPath);
  const tests = extractTestTimings(results);
  const fileStats = aggregateByFile(results);
  
  // Print reports
  printSlowTests(tests, 20);
  printSlowFiles(fileStats, 20);
  printSummary(results);
  checkOpenHandles(results);
  generateRecommendations(tests, fileStats);
  
  console.log(`\n${colors.gray}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${colors.reset}\n`);
}

// Run the profiler
main();
